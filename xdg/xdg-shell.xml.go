// This file is autogenerated from: xdg/xdg-shell.xml
// Do not edit

// Package xdg implements the xdg_shell protocol
package xdg

import (
	"sync"

)
// WmBaseErrorRole means given wl_surface has another role
const WmBaseErrorRole = 0

// WmBaseErrorDefunctSurfaces means xdg_wm_base was destroyed before children
const WmBaseErrorDefunctSurfaces = 1

// WmBaseErrorNotTheTopmostPopup means the client tried to map or destroy a non-topmost popup
const WmBaseErrorNotTheTopmostPopup = 2

// WmBaseErrorInvalidPopupParent means the client specified an invalid popup parent surface
const WmBaseErrorInvalidPopupParent = 3

// WmBaseErrorInvalidSurfaceState means the client provided an invalid surface state
const WmBaseErrorInvalidSurfaceState = 4

// WmBaseErrorInvalidPositioner means the client provided an invalid positioner
const WmBaseErrorInvalidPositioner = 5

// WmBaseErrorUnresponsive means the client didnâ€™t respond to a ping event in time
const WmBaseErrorUnresponsive = 6

// PositionerErrorInvalidInput means invalid input provided
const PositionerErrorInvalidInput = 0

// PositionerAnchorNone
const PositionerAnchorNone = 0

// PositionerAnchorTop
const PositionerAnchorTop = 1

// PositionerAnchorBottom
const PositionerAnchorBottom = 2

// PositionerAnchorLeft
const PositionerAnchorLeft = 3

// PositionerAnchorRight
const PositionerAnchorRight = 4

// PositionerAnchorTopLeft
const PositionerAnchorTopLeft = 5

// PositionerAnchorBottomLeft
const PositionerAnchorBottomLeft = 6

// PositionerAnchorTopRight
const PositionerAnchorTopRight = 7

// PositionerAnchorBottomRight
const PositionerAnchorBottomRight = 8

// PositionerGravityNone
const PositionerGravityNone = 0

// PositionerGravityTop
const PositionerGravityTop = 1

// PositionerGravityBottom
const PositionerGravityBottom = 2

// PositionerGravityLeft
const PositionerGravityLeft = 3

// PositionerGravityRight
const PositionerGravityRight = 4

// PositionerGravityTopLeft
const PositionerGravityTopLeft = 5

// PositionerGravityBottomLeft
const PositionerGravityBottomLeft = 6

// PositionerGravityTopRight
const PositionerGravityTopRight = 7

// PositionerGravityBottomRight
const PositionerGravityBottomRight = 8

// PositionerConstraintAdjustmentNone
const PositionerConstraintAdjustmentNone = 0

// PositionerConstraintAdjustmentSlideX
const PositionerConstraintAdjustmentSlideX = 1

// PositionerConstraintAdjustmentSlideY
const PositionerConstraintAdjustmentSlideY = 2

// PositionerConstraintAdjustmentFlipX
const PositionerConstraintAdjustmentFlipX = 4

// PositionerConstraintAdjustmentFlipY
const PositionerConstraintAdjustmentFlipY = 8

// PositionerConstraintAdjustmentResizeX
const PositionerConstraintAdjustmentResizeX = 16

// PositionerConstraintAdjustmentResizeY
const PositionerConstraintAdjustmentResizeY = 32

// SurfaceErrorNotConstructed means Surface was not fully constructed
const SurfaceErrorNotConstructed = 1

// SurfaceErrorAlreadyConstructed means Surface was already constructed
const SurfaceErrorAlreadyConstructed = 2

// SurfaceErrorUnconfiguredBuffer means Attaching a buffer to an unconfigured surface
const SurfaceErrorUnconfiguredBuffer = 3

// SurfaceErrorInvalidSerial means Invalid serial number when acking a configure event
const SurfaceErrorInvalidSerial = 4

// SurfaceErrorInvalidSize means Width or height was zero or negative
const SurfaceErrorInvalidSize = 5

// SurfaceErrorDefunctRoleObject means Surface was destroyed before its role object
const SurfaceErrorDefunctRoleObject = 6

// ToplevelErrorInvalidResizeEdge means provided value is not a valid variant of the resize_edge enum
const ToplevelErrorInvalidResizeEdge = 0

// ToplevelErrorInvalidParent means invalid parent toplevel
const ToplevelErrorInvalidParent = 1

// ToplevelErrorInvalidSize means client provided an invalid min or max size
const ToplevelErrorInvalidSize = 2

// ToplevelResizeEdgeNone
const ToplevelResizeEdgeNone = 0

// ToplevelResizeEdgeTop
const ToplevelResizeEdgeTop = 1

// ToplevelResizeEdgeBottom
const ToplevelResizeEdgeBottom = 2

// ToplevelResizeEdgeLeft
const ToplevelResizeEdgeLeft = 4

// ToplevelResizeEdgeTopLeft
const ToplevelResizeEdgeTopLeft = 5

// ToplevelResizeEdgeBottomLeft
const ToplevelResizeEdgeBottomLeft = 6

// ToplevelResizeEdgeRight
const ToplevelResizeEdgeRight = 8

// ToplevelResizeEdgeTopRight
const ToplevelResizeEdgeTopRight = 9

// ToplevelResizeEdgeBottomRight
const ToplevelResizeEdgeBottomRight = 10

// ToplevelStateMaximized means the surface is maximized
const ToplevelStateMaximized = 1

// ToplevelStateFullscreen means the surface is fullscreen
const ToplevelStateFullscreen = 2

// ToplevelStateResizing means the surface is being resized
const ToplevelStateResizing = 3

// ToplevelStateActivated means the surface is now activated
const ToplevelStateActivated = 4

// ToplevelStateTiledLeft
const ToplevelStateTiledLeft = 5

// ToplevelStateTiledRight
const ToplevelStateTiledRight = 6

// ToplevelStateTiledTop
const ToplevelStateTiledTop = 7

// ToplevelStateTiledBottom
const ToplevelStateTiledBottom = 8

// ToplevelStateSuspended
const ToplevelStateSuspended = 9

// ToplevelWmCapabilitiesWindowMenu means show_window_menu is available
const ToplevelWmCapabilitiesWindowMenu = 1

// ToplevelWmCapabilitiesMaximize means set_maximized and unset_maximized are available
const ToplevelWmCapabilitiesMaximize = 2

// ToplevelWmCapabilitiesFullscreen means set_fullscreen and unset_fullscreen are available
const ToplevelWmCapabilitiesFullscreen = 3

// ToplevelWmCapabilitiesMinimize means set_minimized is available
const ToplevelWmCapabilitiesMinimize = 4

// PopupErrorInvalidGrab means tried to grab after being mapped
const PopupErrorInvalidGrab = 0

// WmBase create desktop-style surfaces
type WmBase struct {
	BaseProxy
	mu sync.RWMutex
	privateWmBasePings map[WmBasePingHandler]struct{}
}
// initWmBase initializes the WmBase object's handler maps
func (ret *WmBase) initWmBase() {
	ret.privateWmBasePings = make(map[WmBasePingHandler]struct{})
}
// NewWmBase is a constructor for the WmBase object
func NewWmBase(ctx *Context) *WmBase {
	ret := new(WmBase)
	ret.initWmBase()
	ctx.Register(ret)
	return ret
}
// Destroy destroy xdg_wm_base
func (p *WmBase) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// CreatePositioner create a positioner object
func (p *WmBase) CreatePositioner() (*Positioner, error) {
	retId := NewPositioner(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}
// GetSurface create a shell surface from a surface
func (p *WmBase) GetSurface(Surface *WlSurface) (*Surface, error) {
	retId := NewSurface(p.Context())
	return retId, p.Context().SendRequest(p, 2, retId, Surface)
}
// Pong respond to a ping event
func (p *WmBase) Pong(Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 3, Serial)
}
// Dispatch dispatches event for object WmBase
func (p *WmBase) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateWmBasePings) > 0 {
			ev := WmBasePingEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for h := range p.privateWmBasePings {
				h.HandleWmBasePing(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// WmBasePingEvent is the check if the client is alive
type WmBasePingEvent struct {
	// Serial is the pass this to the pong request
	Serial uint32

}
// WmBasePingHandler is the handler interface for WmBasePingEvent
type WmBasePingHandler interface {
	HandleWmBasePing(WmBasePingEvent)
}

// AddPingHandler adds the Ping handler
func (p *WmBase) AddPingHandler(h WmBasePingHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateWmBasePings[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemovePingHandler removes the Ping handler
func (p *WmBase) RemovePingHandler(h WmBasePingHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateWmBasePings, h)
}
// Positioner child surface positioner
type Positioner struct {
	BaseProxy
}
// NewPositioner is a constructor for the Positioner object
func NewPositioner(ctx *Context) *Positioner {
	ret := new(Positioner)
	ctx.Register(ret)
	return ret
}
// Destroy destroy the xdg_positioner object
func (p *Positioner) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// SetSize set the size of the to-be positioned rectangle
func (p *Positioner) SetSize(Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 1, Width, Height)
}
// SetAnchorRect set the anchor rectangle within the parent surface
func (p *Positioner) SetAnchorRect(X int32, Y int32, Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 2, X, Y, Width, Height)
}
// SetAnchor set anchor rectangle anchor
func (p *Positioner) SetAnchor(Anchor uint32) (error) {
	
	return p.Context().SendRequest(p, 3, Anchor)
}
// SetGravity set child surface gravity
func (p *Positioner) SetGravity(Gravity uint32) (error) {
	
	return p.Context().SendRequest(p, 4, Gravity)
}
// SetConstraintAdjustment set the adjustment to be done when constrained
func (p *Positioner) SetConstraintAdjustment(ConstraintAdjustment uint32) (error) {
	
	return p.Context().SendRequest(p, 5, ConstraintAdjustment)
}
// SetOffset set surface position offset
func (p *Positioner) SetOffset(X int32, Y int32) (error) {
	
	return p.Context().SendRequest(p, 6, X, Y)
}
// SetReactive continuously reconstrain the surface
func (p *Positioner) SetReactive() (error) {
	
	return p.Context().SendRequest(p, 7)
}
// SetParentSize 
func (p *Positioner) SetParentSize(ParentWidth int32, ParentHeight int32) (error) {
	
	return p.Context().SendRequest(p, 8, ParentWidth, ParentHeight)
}
// SetParentConfigure set parent configure this is a response to
func (p *Positioner) SetParentConfigure(Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 9, Serial)
}
// Dispatch dispatches event for object Positioner
func (p *Positioner) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// Surface desktop user interface surface base interface
type Surface struct {
	BaseProxy
	mu sync.RWMutex
	privateSurfaceConfigures map[SurfaceConfigureHandler]struct{}
}
// initSurface initializes the Surface object's handler maps
func (ret *Surface) initSurface() {
	ret.privateSurfaceConfigures = make(map[SurfaceConfigureHandler]struct{})
}
// NewSurface is a constructor for the Surface object
func NewSurface(ctx *Context) *Surface {
	ret := new(Surface)
	ret.initSurface()
	ctx.Register(ret)
	return ret
}
// Destroy destroy the xdg_surface
func (p *Surface) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// GetToplevel assign the xdg_toplevel surface role
func (p *Surface) GetToplevel() (*Toplevel, error) {
	retId := NewToplevel(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}
// GetPopup assign the xdg_popup surface role
func (p *Surface) GetPopup(Parent *Surface, Positioner *Positioner) (*Popup, error) {
	retId := NewPopup(p.Context())
	return retId, p.Context().SendRequest(p, 2, retId, Parent, Positioner)
}
// SetWindowGeometry set the new window geometry
func (p *Surface) SetWindowGeometry(X int32, Y int32, Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 3, X, Y, Width, Height)
}
// AckConfigure ack a configure event
func (p *Surface) AckConfigure(Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 4, Serial)
}
// Dispatch dispatches event for object Surface
func (p *Surface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateSurfaceConfigures) > 0 {
			ev := SurfaceConfigureEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for h := range p.privateSurfaceConfigures {
				h.HandleSurfaceConfigure(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// SurfaceConfigureEvent is the suggest a surface change
type SurfaceConfigureEvent struct {
	// Serial is the serial of the configure event
	Serial uint32

}
// SurfaceConfigureHandler is the handler interface for SurfaceConfigureEvent
type SurfaceConfigureHandler interface {
	HandleSurfaceConfigure(SurfaceConfigureEvent)
}

// AddConfigureHandler adds the Configure handler
func (p *Surface) AddConfigureHandler(h SurfaceConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfaceConfigures[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler removes the Configure handler
func (p *Surface) RemoveConfigureHandler(h SurfaceConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateSurfaceConfigures, h)
}
// Toplevel toplevel surface
type Toplevel struct {
	BaseProxy
	mu sync.RWMutex
	privateToplevelConfigures map[ToplevelConfigureHandler]struct{}
	privateToplevelCloses map[ToplevelCloseHandler]struct{}
	privateToplevelConfigureBoundss map[ToplevelConfigureBoundsHandler]struct{}
	privateToplevelWmCapabilitiess map[ToplevelWmCapabilitiesHandler]struct{}
}
// initToplevel initializes the Toplevel object's handler maps
func (ret *Toplevel) initToplevel() {
	ret.privateToplevelConfigures = make(map[ToplevelConfigureHandler]struct{})
	ret.privateToplevelCloses = make(map[ToplevelCloseHandler]struct{})
	ret.privateToplevelConfigureBoundss = make(map[ToplevelConfigureBoundsHandler]struct{})
	ret.privateToplevelWmCapabilitiess = make(map[ToplevelWmCapabilitiesHandler]struct{})
}
// NewToplevel is a constructor for the Toplevel object
func NewToplevel(ctx *Context) *Toplevel {
	ret := new(Toplevel)
	ret.initToplevel()
	ctx.Register(ret)
	return ret
}
// Destroy destroy the xdg_toplevel
func (p *Toplevel) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// SetParent set the parent of this surface
func (p *Toplevel) SetParent(Parent *Toplevel) (error) {
	
	return p.Context().SendRequest(p, 1, Parent)
}
// SetTitle set surface title
func (p *Toplevel) SetTitle(Title string) (error) {
	
	return p.Context().SendRequest(p, 2, Title)
}
// SetAppId set application ID
func (p *Toplevel) SetAppId(AppId string) (error) {
	
	return p.Context().SendRequest(p, 3, AppId)
}
// ShowWindowMenu show the window menu
func (p *Toplevel) ShowWindowMenu(Seat *Seat, Serial uint32, X int32, Y int32) (error) {
	
	return p.Context().SendRequest(p, 4, Seat, Serial, X, Y)
}
// Move start an interactive move
func (p *Toplevel) Move(Seat *Seat, Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 5, Seat, Serial)
}
// Resize start an interactive resize
func (p *Toplevel) Resize(Seat *Seat, Serial uint32, Edges uint32) (error) {
	
	return p.Context().SendRequest(p, 6, Seat, Serial, Edges)
}
// SetMaxSize set the maximum size
func (p *Toplevel) SetMaxSize(Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 7, Width, Height)
}
// SetMinSize set the minimum size
func (p *Toplevel) SetMinSize(Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 8, Width, Height)
}
// SetMaximized maximize the window
func (p *Toplevel) SetMaximized() (error) {
	
	return p.Context().SendRequest(p, 9)
}
// UnsetMaximized unmaximize the window
func (p *Toplevel) UnsetMaximized() (error) {
	
	return p.Context().SendRequest(p, 10)
}
// SetFullscreen set the window as fullscreen on an output
func (p *Toplevel) SetFullscreen(Output *Output) (error) {
	
	return p.Context().SendRequest(p, 11, Output)
}
// UnsetFullscreen unset the window as fullscreen
func (p *Toplevel) UnsetFullscreen() (error) {
	
	return p.Context().SendRequest(p, 12)
}
// SetMinimized set the window as minimized
func (p *Toplevel) SetMinimized() (error) {
	
	return p.Context().SendRequest(p, 13)
}
// Dispatch dispatches event for object Toplevel
func (p *Toplevel) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateToplevelConfigures) > 0 {
			ev := ToplevelConfigureEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			ev.States = event.Array()
			p.mu.RLock()
			for h := range p.privateToplevelConfigures {
				h.HandleToplevelConfigure(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateToplevelCloses) > 0 {
			ev := ToplevelCloseEvent{}
			p.mu.RLock()
			for h := range p.privateToplevelCloses {
				h.HandleToplevelClose(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateToplevelConfigureBoundss) > 0 {
			ev := ToplevelConfigureBoundsEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for h := range p.privateToplevelConfigureBoundss {
				h.HandleToplevelConfigureBounds(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateToplevelWmCapabilitiess) > 0 {
			ev := ToplevelWmCapabilitiesEvent{}
			ev.Capabilities = event.Array()
			p.mu.RLock()
			for h := range p.privateToplevelWmCapabilitiess {
				h.HandleToplevelWmCapabilities(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// ToplevelConfigureEvent is the suggest a surface change
type ToplevelConfigureEvent struct {
	// Width is the 
	Width int32
	// Height is the 
	Height int32
	// States is the 
	States []int32

}
// ToplevelCloseEvent is the surface wants to be closed
type ToplevelCloseEvent struct {

}
// ToplevelConfigureBoundsEvent is the recommended window geometry bounds
type ToplevelConfigureBoundsEvent struct {
	// Width is the 
	Width int32
	// Height is the 
	Height int32

}
// ToplevelWmCapabilitiesEvent is the compositor capabilities
type ToplevelWmCapabilitiesEvent struct {
	// Capabilities is the array of 32-bit capabilities
	Capabilities []int32

}
// ToplevelConfigureHandler is the handler interface for ToplevelConfigureEvent
type ToplevelConfigureHandler interface {
	HandleToplevelConfigure(ToplevelConfigureEvent)
}

// AddConfigureHandler adds the Configure handler
func (p *Toplevel) AddConfigureHandler(h ToplevelConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelConfigures[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler removes the Configure handler
func (p *Toplevel) RemoveConfigureHandler(h ToplevelConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateToplevelConfigures, h)
}
// ToplevelCloseHandler is the handler interface for ToplevelCloseEvent
type ToplevelCloseHandler interface {
	HandleToplevelClose(ToplevelCloseEvent)
}

// AddCloseHandler adds the Close handler
func (p *Toplevel) AddCloseHandler(h ToplevelCloseHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelCloses[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveCloseHandler removes the Close handler
func (p *Toplevel) RemoveCloseHandler(h ToplevelCloseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateToplevelCloses, h)
}
// ToplevelConfigureBoundsHandler is the handler interface for ToplevelConfigureBoundsEvent
type ToplevelConfigureBoundsHandler interface {
	HandleToplevelConfigureBounds(ToplevelConfigureBoundsEvent)
}

// AddConfigureBoundsHandler adds the ConfigureBounds handler
func (p *Toplevel) AddConfigureBoundsHandler(h ToplevelConfigureBoundsHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelConfigureBoundss[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveConfigureBoundsHandler removes the ConfigureBounds handler
func (p *Toplevel) RemoveConfigureBoundsHandler(h ToplevelConfigureBoundsHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateToplevelConfigureBoundss, h)
}
// ToplevelWmCapabilitiesHandler is the handler interface for ToplevelWmCapabilitiesEvent
type ToplevelWmCapabilitiesHandler interface {
	HandleToplevelWmCapabilities(ToplevelWmCapabilitiesEvent)
}

// AddWmCapabilitiesHandler adds the WmCapabilities handler
func (p *Toplevel) AddWmCapabilitiesHandler(h ToplevelWmCapabilitiesHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateToplevelWmCapabilitiess[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveWmCapabilitiesHandler removes the WmCapabilities handler
func (p *Toplevel) RemoveWmCapabilitiesHandler(h ToplevelWmCapabilitiesHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateToplevelWmCapabilitiess, h)
}
// Popup short-lived, popup surfaces for menus
type Popup struct {
	BaseProxy
	mu sync.RWMutex
	privatePopupConfigures map[PopupConfigureHandler]struct{}
	privatePopupPopupDones map[PopupPopupDoneHandler]struct{}
	privatePopupRepositioneds map[PopupRepositionedHandler]struct{}
}
// initPopup initializes the Popup object's handler maps
func (ret *Popup) initPopup() {
	ret.privatePopupConfigures = make(map[PopupConfigureHandler]struct{})
	ret.privatePopupPopupDones = make(map[PopupPopupDoneHandler]struct{})
	ret.privatePopupRepositioneds = make(map[PopupRepositionedHandler]struct{})
}
// NewPopup is a constructor for the Popup object
func NewPopup(ctx *Context) *Popup {
	ret := new(Popup)
	ret.initPopup()
	ctx.Register(ret)
	return ret
}
// Destroy remove xdg_popup interface
func (p *Popup) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// Grab make the popup take an explicit grab
func (p *Popup) Grab(Seat *Seat, Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 1, Seat, Serial)
}
// Reposition recalculate the popup's location
func (p *Popup) Reposition(Positioner *Positioner, Token uint32) (error) {
	
	return p.Context().SendRequest(p, 2, Positioner, Token)
}
// Dispatch dispatches event for object Popup
func (p *Popup) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privatePopupConfigures) > 0 {
			ev := PopupConfigureEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for h := range p.privatePopupConfigures {
				h.HandlePopupConfigure(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privatePopupPopupDones) > 0 {
			ev := PopupPopupDoneEvent{}
			p.mu.RLock()
			for h := range p.privatePopupPopupDones {
				h.HandlePopupPopupDone(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privatePopupRepositioneds) > 0 {
			ev := PopupRepositionedEvent{}
			ev.Token = event.Uint32()
			p.mu.RLock()
			for h := range p.privatePopupRepositioneds {
				h.HandlePopupRepositioned(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// PopupConfigureEvent is the configure the popup surface
type PopupConfigureEvent struct {
	// X is the x position relative to parent surface window geometry
	X int32
	// Y is the y position relative to parent surface window geometry
	Y int32
	// Width is the window geometry width
	Width int32
	// Height is the window geometry height
	Height int32

}
// PopupPopupDoneEvent is the popup interaction is done
type PopupPopupDoneEvent struct {

}
// PopupRepositionedEvent is the signal the completion of a repositioned request
type PopupRepositionedEvent struct {
	// Token is the reposition request token
	Token uint32

}
// PopupConfigureHandler is the handler interface for PopupConfigureEvent
type PopupConfigureHandler interface {
	HandlePopupConfigure(PopupConfigureEvent)
}

// AddConfigureHandler adds the Configure handler
func (p *Popup) AddConfigureHandler(h PopupConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePopupConfigures[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler removes the Configure handler
func (p *Popup) RemoveConfigureHandler(h PopupConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePopupConfigures, h)
}
// PopupPopupDoneHandler is the handler interface for PopupPopupDoneEvent
type PopupPopupDoneHandler interface {
	HandlePopupPopupDone(PopupPopupDoneEvent)
}

// AddPopupDoneHandler adds the PopupDone handler
func (p *Popup) AddPopupDoneHandler(h PopupPopupDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePopupPopupDones[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemovePopupDoneHandler removes the PopupDone handler
func (p *Popup) RemovePopupDoneHandler(h PopupPopupDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePopupPopupDones, h)
}
// PopupRepositionedHandler is the handler interface for PopupRepositionedEvent
type PopupRepositionedHandler interface {
	HandlePopupRepositioned(PopupRepositionedEvent)
}

// AddRepositionedHandler adds the Repositioned handler
func (p *Popup) AddRepositionedHandler(h PopupRepositionedHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePopupRepositioneds[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveRepositionedHandler removes the Repositioned handler
func (p *Popup) RemoveRepositionedHandler(h PopupRepositionedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePopupRepositioneds, h)
}
