// This file is autogenerated from: ../../wl/wayland.xml
// Do not edit

// Package wl implements the wayland protocol
package wl

import (
	"sync"
)

// DisplayErrorInvalidObject means server couldn't find object
const DisplayErrorInvalidObject = 0

// DisplayErrorInvalidMethod means method doesn't exist on the specified interface or malformed request
const DisplayErrorInvalidMethod = 1

// DisplayErrorNoMemory means server is out of memory
const DisplayErrorNoMemory = 2

// DisplayErrorImplementation means implementation error in compositor
const DisplayErrorImplementation = 3

// ShmErrorInvalidFormat means buffer format is not known
const ShmErrorInvalidFormat = 0

// ShmErrorInvalidStride means invalid size or stride during pool or buffer creation
const ShmErrorInvalidStride = 1

// ShmErrorInvalidFd means mmapping the file descriptor failed
const ShmErrorInvalidFd = 2

// ShmFormatArgb8888 means 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
const ShmFormatArgb8888 = 0

// ShmFormatXrgb8888 means 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
const ShmFormatXrgb8888 = 1

// ShmFormatC8 means 8-bit color index format, [7:0] C
const ShmFormatC8 = 0x20203843

// ShmFormatRgb332 means 8-bit RGB format, [7:0] R:G:B 3:3:2
const ShmFormatRgb332 = 0x38424752

// ShmFormatBgr233 means 8-bit BGR format, [7:0] B:G:R 2:3:3
const ShmFormatBgr233 = 0x38524742

// ShmFormatXrgb4444 means 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
const ShmFormatXrgb4444 = 0x32315258

// ShmFormatXbgr4444 means 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
const ShmFormatXbgr4444 = 0x32314258

// ShmFormatRgbx4444 means 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
const ShmFormatRgbx4444 = 0x32315852

// ShmFormatBgrx4444 means 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
const ShmFormatBgrx4444 = 0x32315842

// ShmFormatArgb4444 means 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
const ShmFormatArgb4444 = 0x32315241

// ShmFormatAbgr4444 means 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
const ShmFormatAbgr4444 = 0x32314241

// ShmFormatRgba4444 means 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
const ShmFormatRgba4444 = 0x32314152

// ShmFormatBgra4444 means 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
const ShmFormatBgra4444 = 0x32314142

// ShmFormatXrgb1555 means 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
const ShmFormatXrgb1555 = 0x35315258

// ShmFormatXbgr1555 means 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
const ShmFormatXbgr1555 = 0x35314258

// ShmFormatRgbx5551 means 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
const ShmFormatRgbx5551 = 0x35315852

// ShmFormatBgrx5551 means 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
const ShmFormatBgrx5551 = 0x35315842

// ShmFormatArgb1555 means 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
const ShmFormatArgb1555 = 0x35315241

// ShmFormatAbgr1555 means 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
const ShmFormatAbgr1555 = 0x35314241

// ShmFormatRgba5551 means 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
const ShmFormatRgba5551 = 0x35314152

// ShmFormatBgra5551 means 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
const ShmFormatBgra5551 = 0x35314142

// ShmFormatRgb565 means 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
const ShmFormatRgb565 = 0x36314752

// ShmFormatBgr565 means 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
const ShmFormatBgr565 = 0x36314742

// ShmFormatRgb888 means 24-bit RGB format, [23:0] R:G:B little endian
const ShmFormatRgb888 = 0x34324752

// ShmFormatBgr888 means 24-bit BGR format, [23:0] B:G:R little endian
const ShmFormatBgr888 = 0x34324742

// ShmFormatXbgr8888 means 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
const ShmFormatXbgr8888 = 0x34324258

// ShmFormatRgbx8888 means 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
const ShmFormatRgbx8888 = 0x34325852

// ShmFormatBgrx8888 means 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
const ShmFormatBgrx8888 = 0x34325842

// ShmFormatAbgr8888 means 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
const ShmFormatAbgr8888 = 0x34324241

// ShmFormatRgba8888 means 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
const ShmFormatRgba8888 = 0x34324152

// ShmFormatBgra8888 means 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
const ShmFormatBgra8888 = 0x34324142

// ShmFormatXrgb2101010 means 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
const ShmFormatXrgb2101010 = 0x30335258

// ShmFormatXbgr2101010 means 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
const ShmFormatXbgr2101010 = 0x30334258

// ShmFormatRgbx1010102 means 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
const ShmFormatRgbx1010102 = 0x30335852

// ShmFormatBgrx1010102 means 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
const ShmFormatBgrx1010102 = 0x30335842

// ShmFormatArgb2101010 means 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
const ShmFormatArgb2101010 = 0x30335241

// ShmFormatAbgr2101010 means 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
const ShmFormatAbgr2101010 = 0x30334241

// ShmFormatRgba1010102 means 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
const ShmFormatRgba1010102 = 0x30334152

// ShmFormatBgra1010102 means 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
const ShmFormatBgra1010102 = 0x30334142

// ShmFormatYuyv means packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
const ShmFormatYuyv = 0x56595559

// ShmFormatYvyu means packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
const ShmFormatYvyu = 0x55595659

// ShmFormatUyvy means packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
const ShmFormatUyvy = 0x59565955

// ShmFormatVyuy means packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
const ShmFormatVyuy = 0x59555956

// ShmFormatAyuv means packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
const ShmFormatAyuv = 0x56555941

// ShmFormatNv12 means 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
const ShmFormatNv12 = 0x3231564e

// ShmFormatNv21 means 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
const ShmFormatNv21 = 0x3132564e

// ShmFormatNv16 means 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
const ShmFormatNv16 = 0x3631564e

// ShmFormatNv61 means 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
const ShmFormatNv61 = 0x3136564e

// ShmFormatYuv410 means 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv410 = 0x39565559

// ShmFormatYvu410 means 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu410 = 0x39555659

// ShmFormatYuv411 means 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv411 = 0x31315559

// ShmFormatYvu411 means 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu411 = 0x31315659

// ShmFormatYuv420 means 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv420 = 0x32315559

// ShmFormatYvu420 means 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu420 = 0x32315659

// ShmFormatYuv422 means 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv422 = 0x36315559

// ShmFormatYvu422 means 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu422 = 0x36315659

// ShmFormatYuv444 means 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv444 = 0x34325559

// ShmFormatYvu444 means 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu444 = 0x34325659

// ShmFormatR8 means [7:0] R
const ShmFormatR8 = 0x20203852

// ShmFormatR16 means [15:0] R little endian
const ShmFormatR16 = 0x20363152

// ShmFormatRg88 means [15:0] R:G 8:8 little endian
const ShmFormatRg88 = 0x38384752

// ShmFormatGr88 means [15:0] G:R 8:8 little endian
const ShmFormatGr88 = 0x38385247

// ShmFormatRg1616 means [31:0] R:G 16:16 little endian
const ShmFormatRg1616 = 0x32334752

// ShmFormatGr1616 means [31:0] G:R 16:16 little endian
const ShmFormatGr1616 = 0x32335247

// ShmFormatXrgb16161616f means [63:0] x:R:G:B 16:16:16:16 little endian
const ShmFormatXrgb16161616f = 0x48345258

// ShmFormatXbgr16161616f means [63:0] x:B:G:R 16:16:16:16 little endian
const ShmFormatXbgr16161616f = 0x48344258

// ShmFormatArgb16161616f means [63:0] A:R:G:B 16:16:16:16 little endian
const ShmFormatArgb16161616f = 0x48345241

// ShmFormatAbgr16161616f means [63:0] A:B:G:R 16:16:16:16 little endian
const ShmFormatAbgr16161616f = 0x48344241

// ShmFormatXyuv8888 means [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
const ShmFormatXyuv8888 = 0x56555958

// ShmFormatVuy888 means [23:0] Cr:Cb:Y 8:8:8 little endian
const ShmFormatVuy888 = 0x34325556

// ShmFormatVuy101010 means Y followed by U then V, 10:10:10. Non-linear modifier only
const ShmFormatVuy101010 = 0x30335556

// ShmFormatY210 means [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
const ShmFormatY210 = 0x30313259

// ShmFormatY212 means [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
const ShmFormatY212 = 0x32313259

// ShmFormatY216 means [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
const ShmFormatY216 = 0x36313259

// ShmFormatY410 means [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
const ShmFormatY410 = 0x30313459

// ShmFormatY412 means [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
const ShmFormatY412 = 0x32313459

// ShmFormatY416 means [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
const ShmFormatY416 = 0x36313459

// ShmFormatXvyu2101010 means [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
const ShmFormatXvyu2101010 = 0x30335658

// ShmFormatXvyu1216161616 means [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
const ShmFormatXvyu1216161616 = 0x36335658

// ShmFormatXvyu16161616 means [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
const ShmFormatXvyu16161616 = 0x38345658

// ShmFormatY0l0 means [63:0]  A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
const ShmFormatY0l0 = 0x304c3059

// ShmFormatX0l0 means [63:0]  X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
const ShmFormatX0l0 = 0x304c3058

// ShmFormatY0l2 means [63:0]  A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
const ShmFormatY0l2 = 0x324c3059

// ShmFormatX0l2 means [63:0]  X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
const ShmFormatX0l2 = 0x324c3058

// ShmFormatYuv4208bit
const ShmFormatYuv4208bit = 0x38305559

// ShmFormatYuv42010bit
const ShmFormatYuv42010bit = 0x30315559

// ShmFormatXrgb8888A8
const ShmFormatXrgb8888A8 = 0x38415258

// ShmFormatXbgr8888A8
const ShmFormatXbgr8888A8 = 0x38414258

// ShmFormatRgbx8888A8
const ShmFormatRgbx8888A8 = 0x38415852

// ShmFormatBgrx8888A8
const ShmFormatBgrx8888A8 = 0x38415842

// ShmFormatRgb888A8
const ShmFormatRgb888A8 = 0x38413852

// ShmFormatBgr888A8
const ShmFormatBgr888A8 = 0x38413842

// ShmFormatRgb565A8
const ShmFormatRgb565A8 = 0x38413552

// ShmFormatBgr565A8
const ShmFormatBgr565A8 = 0x38413542

// ShmFormatNv24 means non-subsampled Cr:Cb plane
const ShmFormatNv24 = 0x3432564e

// ShmFormatNv42 means non-subsampled Cb:Cr plane
const ShmFormatNv42 = 0x3234564e

// ShmFormatP210 means 2x1 subsampled Cr:Cb plane, 10 bit per channel
const ShmFormatP210 = 0x30313250

// ShmFormatP010 means 2x2 subsampled Cr:Cb plane 10 bits per channel
const ShmFormatP010 = 0x30313050

// ShmFormatP012 means 2x2 subsampled Cr:Cb plane 12 bits per channel
const ShmFormatP012 = 0x32313050

// ShmFormatP016 means 2x2 subsampled Cr:Cb plane 16 bits per channel
const ShmFormatP016 = 0x36313050

// ShmFormatAxbxgxrx106106106106 means [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
const ShmFormatAxbxgxrx106106106106 = 0x30314241

// ShmFormatNv15 means 2x2 subsampled Cr:Cb plane
const ShmFormatNv15 = 0x3531564e

// ShmFormatQ410
const ShmFormatQ410 = 0x30313451

// ShmFormatQ401
const ShmFormatQ401 = 0x31303451

// ShmFormatXrgb16161616 means [63:0] x:R:G:B 16:16:16:16 little endian
const ShmFormatXrgb16161616 = 0x38345258

// ShmFormatXbgr16161616 means [63:0] x:B:G:R 16:16:16:16 little endian
const ShmFormatXbgr16161616 = 0x38344258

// ShmFormatArgb16161616 means [63:0] A:R:G:B 16:16:16:16 little endian
const ShmFormatArgb16161616 = 0x38345241

// ShmFormatAbgr16161616 means [63:0] A:B:G:R 16:16:16:16 little endian
const ShmFormatAbgr16161616 = 0x38344241

// ShmFormatC1 means [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
const ShmFormatC1 = 0x20203143

// ShmFormatC2 means [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
const ShmFormatC2 = 0x20203243

// ShmFormatC4 means [7:0] C0:C1 4:4 two pixels/byte
const ShmFormatC4 = 0x20203443

// ShmFormatD1 means [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
const ShmFormatD1 = 0x20203144

// ShmFormatD2 means [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
const ShmFormatD2 = 0x20203244

// ShmFormatD4 means [7:0] D0:D1 4:4 two pixels/byte
const ShmFormatD4 = 0x20203444

// ShmFormatD8 means [7:0] D
const ShmFormatD8 = 0x20203844

// ShmFormatR1 means [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
const ShmFormatR1 = 0x20203152

// ShmFormatR2 means [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
const ShmFormatR2 = 0x20203252

// ShmFormatR4 means [7:0] R0:R1 4:4 two pixels/byte
const ShmFormatR4 = 0x20203452

// ShmFormatR10 means [15:0] x:R 6:10 little endian
const ShmFormatR10 = 0x20303152

// ShmFormatR12 means [15:0] x:R 4:12 little endian
const ShmFormatR12 = 0x20323152

// ShmFormatAvuy8888 means [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
const ShmFormatAvuy8888 = 0x59555641

// ShmFormatXvuy8888 means [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
const ShmFormatXvuy8888 = 0x59555658

// ShmFormatP030 means 2x2 subsampled Cr:Cb plane 10 bits per channel packed
const ShmFormatP030 = 0x30333050

// DataOfferErrorInvalidFinish means finish request was called untimely
const DataOfferErrorInvalidFinish = 0

// DataOfferErrorInvalidActionMask means action mask contains invalid values
const DataOfferErrorInvalidActionMask = 1

// DataOfferErrorInvalidAction means action argument has an invalid value
const DataOfferErrorInvalidAction = 2

// DataOfferErrorInvalidOffer means offer doesn't accept this request
const DataOfferErrorInvalidOffer = 3

// DataSourceErrorInvalidActionMask means action mask contains invalid values
const DataSourceErrorInvalidActionMask = 0

// DataSourceErrorInvalidSource means source doesn't accept this request
const DataSourceErrorInvalidSource = 1

// DataDeviceErrorRole means given wl_surface has another role
const DataDeviceErrorRole = 0

// DataDeviceErrorUsedSource means source has already been used
const DataDeviceErrorUsedSource = 1

// DataDeviceManagerDndActionNone means no action
const DataDeviceManagerDndActionNone = 0

// DataDeviceManagerDndActionCopy means copy action
const DataDeviceManagerDndActionCopy = 1

// DataDeviceManagerDndActionMove means move action
const DataDeviceManagerDndActionMove = 2

// DataDeviceManagerDndActionAsk means ask action
const DataDeviceManagerDndActionAsk = 4

// ShellErrorRole means given wl_surface has another role
const ShellErrorRole = 0

// ShellSurfaceResizeNone means no edge
const ShellSurfaceResizeNone = 0

// ShellSurfaceResizeTop means top edge
const ShellSurfaceResizeTop = 1

// ShellSurfaceResizeBottom means bottom edge
const ShellSurfaceResizeBottom = 2

// ShellSurfaceResizeLeft means left edge
const ShellSurfaceResizeLeft = 4

// ShellSurfaceResizeTopLeft means top and left edges
const ShellSurfaceResizeTopLeft = 5

// ShellSurfaceResizeBottomLeft means bottom and left edges
const ShellSurfaceResizeBottomLeft = 6

// ShellSurfaceResizeRight means right edge
const ShellSurfaceResizeRight = 8

// ShellSurfaceResizeTopRight means top and right edges
const ShellSurfaceResizeTopRight = 9

// ShellSurfaceResizeBottomRight means bottom and right edges
const ShellSurfaceResizeBottomRight = 10

// ShellSurfaceTransientInactive means do not set keyboard focus
const ShellSurfaceTransientInactive = 0x1

// ShellSurfaceFullscreenMethodDefault means no preference, apply default policy
const ShellSurfaceFullscreenMethodDefault = 0

// ShellSurfaceFullscreenMethodScale means scale, preserve the surface's aspect ratio and center on output
const ShellSurfaceFullscreenMethodScale = 1

// ShellSurfaceFullscreenMethodDriver means switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
const ShellSurfaceFullscreenMethodDriver = 2

// ShellSurfaceFullscreenMethodFill means no upscaling, center on output and add black borders to compensate size mismatch
const ShellSurfaceFullscreenMethodFill = 3

// SurfaceErrorInvalidScale means buffer scale value is invalid
const SurfaceErrorInvalidScale = 0

// SurfaceErrorInvalidTransform means buffer transform value is invalid
const SurfaceErrorInvalidTransform = 1

// SurfaceErrorInvalidSize means buffer size is invalid
const SurfaceErrorInvalidSize = 2

// SurfaceErrorInvalidOffset means buffer offset is invalid
const SurfaceErrorInvalidOffset = 3

// SurfaceErrorDefunctRoleObject means surface was destroyed before its role object
const SurfaceErrorDefunctRoleObject = 4

// SeatCapabilityPointer means the seat has pointer devices
const SeatCapabilityPointer = 1

// SeatCapabilityKeyboard means the seat has one or more keyboards
const SeatCapabilityKeyboard = 2

// SeatCapabilityTouch means the seat has touch devices
const SeatCapabilityTouch = 4

// SeatErrorMissingCapability means get_pointer, get_keyboard or get_touch called on seat without the matching capability
const SeatErrorMissingCapability = 0

// PointerErrorRole means given wl_surface has another role
const PointerErrorRole = 0

// PointerButtonStateReleased means the button is not pressed
const PointerButtonStateReleased = 0

// PointerButtonStatePressed means the button is pressed
const PointerButtonStatePressed = 1

// PointerAxisVerticalScroll means vertical axis
const PointerAxisVerticalScroll = 0

// PointerAxisHorizontalScroll means horizontal axis
const PointerAxisHorizontalScroll = 1

// PointerAxisSourceWheel means a physical wheel rotation
const PointerAxisSourceWheel = 0

// PointerAxisSourceFinger means finger on a touch surface
const PointerAxisSourceFinger = 1

// PointerAxisSourceContinuous means continuous coordinate space
const PointerAxisSourceContinuous = 2

// PointerAxisSourceWheelTilt means a physical wheel tilt
const PointerAxisSourceWheelTilt = 3

// PointerAxisRelativeDirectionIdentical means physical motion matches axis direction
const PointerAxisRelativeDirectionIdentical = 0

// PointerAxisRelativeDirectionInverted means physical motion is the inverse of the axis direction
const PointerAxisRelativeDirectionInverted = 1

// KeyboardKeymapFormatNoKeymap means no keymap; client must understand how to interpret the raw keycode
const KeyboardKeymapFormatNoKeymap = 0

// KeyboardKeymapFormatXkbV1 means libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
const KeyboardKeymapFormatXkbV1 = 1

// KeyboardKeyStateReleased means key is not pressed
const KeyboardKeyStateReleased = 0

// KeyboardKeyStatePressed means key is pressed
const KeyboardKeyStatePressed = 1

// OutputSubpixelUnknown means unknown geometry
const OutputSubpixelUnknown = 0

// OutputSubpixelNone means no geometry
const OutputSubpixelNone = 1

// OutputSubpixelHorizontalRgb means horizontal RGB
const OutputSubpixelHorizontalRgb = 2

// OutputSubpixelHorizontalBgr means horizontal BGR
const OutputSubpixelHorizontalBgr = 3

// OutputSubpixelVerticalRgb means vertical RGB
const OutputSubpixelVerticalRgb = 4

// OutputSubpixelVerticalBgr means vertical BGR
const OutputSubpixelVerticalBgr = 5

// OutputTransformNormal means no transform
const OutputTransformNormal = 0

// OutputTransform90 means 90 degrees counter-clockwise
const OutputTransform90 = 1

// OutputTransform180 means 180 degrees counter-clockwise
const OutputTransform180 = 2

// OutputTransform270 means 270 degrees counter-clockwise
const OutputTransform270 = 3

// OutputTransformFlipped means 180 degree flip around a vertical axis
const OutputTransformFlipped = 4

// OutputTransformFlipped90 means flip and rotate 90 degrees counter-clockwise
const OutputTransformFlipped90 = 5

// OutputTransformFlipped180 means flip and rotate 180 degrees counter-clockwise
const OutputTransformFlipped180 = 6

// OutputTransformFlipped270 means flip and rotate 270 degrees counter-clockwise
const OutputTransformFlipped270 = 7

// OutputModeCurrent means indicates this is the current mode
const OutputModeCurrent = 0x1

// OutputModePreferred means indicates this is the preferred mode
const OutputModePreferred = 0x2

// SubcompositorErrorBadSurface means the to-be sub-surface is invalid
const SubcompositorErrorBadSurface = 0

// SubcompositorErrorBadParent means the to-be sub-surface parent is invalid
const SubcompositorErrorBadParent = 1

// SubsurfaceErrorBadSurface means wl_surface is not a sibling or the parent
const SubsurfaceErrorBadSurface = 0

// Display core global object
type Display struct {
	BaseProxy
	mu                      sync.RWMutex
	privateDisplayErrors    []DisplayErrorHandler
	privateDisplayDeleteIds []DisplayDeleteIdHandler
}

// NewDisplay is a constructor for the Display object
func NewDisplay(ctx *Context) *Display {
	ret := new(Display)
	ctx.Register(ret)
	return ret
}

// Sync asynchronous roundtrip
func (p *Display) Sync() (*Callback, error) {
	retCallback := NewCallback(p.Context())
	return retCallback, p.Context().SendRequest(p, 0, retCallback)
}

// GetRegistry get global registry object
func (p *Display) GetRegistry() (*Registry, error) {
	retRegistry := NewRegistry(p.Context())
	return retRegistry, p.Context().SendRequest(p, 1, retRegistry)
}

// Dispatch dispatches event for object Display
func (p *Display) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDisplayErrors) > 0 {
			ev := DisplayErrorEvent{}
			ev.ObjectId = event.Proxy(p.Context())
			ev.Code = event.Uint32()
			ev.Message = event.String()
			p.mu.RLock()
			for _, h := range p.privateDisplayErrors {
				h.HandleDisplayError(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDisplayDeleteIds) > 0 {
			ev := DisplayDeleteIdEvent{}
			ev.Id = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateDisplayDeleteIds {
				h.HandleDisplayDeleteId(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// DisplayErrorEvent is the fatal error event
type DisplayErrorEvent struct {
	// ObjectId is the object where the error occurred
	ObjectId Proxy
	// Code is the error code
	Code uint32
	// Message is the error description
	Message string
}

// DisplayDeleteIdEvent is the acknowledge object ID deletion
type DisplayDeleteIdEvent struct {
	// Id is the deleted object ID
	Id uint32
}

// DisplayErrorHandler is the handler interface for DisplayErrorEvent
type DisplayErrorHandler interface {
	HandleDisplayError(DisplayErrorEvent)
}

// AddErrorHandler removes the Error handler
func (p *Display) AddErrorHandler(h DisplayErrorHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDisplayErrors = append(p.privateDisplayErrors, h)
		p.mu.Unlock()
	}
}

// RemoveErrorHandler adds the Error handler
func (p *Display) RemoveErrorHandler(h DisplayErrorHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDisplayErrors {
		if e == h {
			p.privateDisplayErrors = append(p.privateDisplayErrors[:i], p.privateDisplayErrors[i+1:]...)
			break
		}
	}
}

// DisplayDeleteIdHandler is the handler interface for DisplayDeleteIdEvent
type DisplayDeleteIdHandler interface {
	HandleDisplayDeleteId(DisplayDeleteIdEvent)
}

// AddDeleteIdHandler removes the DeleteId handler
func (p *Display) AddDeleteIdHandler(h DisplayDeleteIdHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDisplayDeleteIds = append(p.privateDisplayDeleteIds, h)
		p.mu.Unlock()
	}
}

// RemoveDeleteIdHandler adds the DeleteId handler
func (p *Display) RemoveDeleteIdHandler(h DisplayDeleteIdHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDisplayDeleteIds {
		if e == h {
			p.privateDisplayDeleteIds = append(p.privateDisplayDeleteIds[:i], p.privateDisplayDeleteIds[i+1:]...)
			break
		}
	}
}

// Registry global registry object
type Registry struct {
	BaseProxy
	mu                           sync.RWMutex
	privateRegistryGlobals       []RegistryGlobalHandler
	privateRegistryGlobalRemoves []RegistryGlobalRemoveHandler
}

// NewRegistry is a constructor for the Registry object
func NewRegistry(ctx *Context) *Registry {
	ret := new(Registry)
	ctx.Register(ret)
	return ret
}

// Bind bind an object to the display
func (p *Registry) Bind(Name uint32, Iface string, Version uint32, Id Proxy) error {

	return p.Context().SendRequest(p, 0, Name, Iface, Version, Id)
}

// Dispatch dispatches event for object Registry
func (p *Registry) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateRegistryGlobals) > 0 {
			ev := RegistryGlobalEvent{}
			ev.Name = event.Uint32()
			ev.Interface = event.String()
			ev.Version = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateRegistryGlobals {
				h.HandleRegistryGlobal(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateRegistryGlobalRemoves) > 0 {
			ev := RegistryGlobalRemoveEvent{}
			ev.Name = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateRegistryGlobalRemoves {
				h.HandleRegistryGlobalRemove(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// RegistryGlobalEvent is the announce global object
type RegistryGlobalEvent struct {
	// Name is the numeric name of the global object
	Name uint32
	// Interface is the interface implemented by the object
	Interface string
	// Version is the interface version
	Version uint32
}

// RegistryGlobalRemoveEvent is the announce removal of global object
type RegistryGlobalRemoveEvent struct {
	// Name is the numeric name of the global object
	Name uint32
}

// RegistryGlobalHandler is the handler interface for RegistryGlobalEvent
type RegistryGlobalHandler interface {
	HandleRegistryGlobal(RegistryGlobalEvent)
}

// AddGlobalHandler removes the Global handler
func (p *Registry) AddGlobalHandler(h RegistryGlobalHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateRegistryGlobals = append(p.privateRegistryGlobals, h)
		p.mu.Unlock()
	}
}

// RemoveGlobalHandler adds the Global handler
func (p *Registry) RemoveGlobalHandler(h RegistryGlobalHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateRegistryGlobals {
		if e == h {
			p.privateRegistryGlobals = append(p.privateRegistryGlobals[:i], p.privateRegistryGlobals[i+1:]...)
			break
		}
	}
}

// RegistryGlobalRemoveHandler is the handler interface for RegistryGlobalRemoveEvent
type RegistryGlobalRemoveHandler interface {
	HandleRegistryGlobalRemove(RegistryGlobalRemoveEvent)
}

// AddGlobalRemoveHandler removes the GlobalRemove handler
func (p *Registry) AddGlobalRemoveHandler(h RegistryGlobalRemoveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateRegistryGlobalRemoves = append(p.privateRegistryGlobalRemoves, h)
		p.mu.Unlock()
	}
}

// RemoveGlobalRemoveHandler adds the GlobalRemove handler
func (p *Registry) RemoveGlobalRemoveHandler(h RegistryGlobalRemoveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateRegistryGlobalRemoves {
		if e == h {
			p.privateRegistryGlobalRemoves = append(p.privateRegistryGlobalRemoves[:i], p.privateRegistryGlobalRemoves[i+1:]...)
			break
		}
	}
}

// Callback callback object
type Callback struct {
	BaseProxy
	mu                   sync.RWMutex
	privateCallbackDones []CallbackDoneHandler
}

// NewCallback is a constructor for the Callback object
func NewCallback(ctx *Context) *Callback {
	ret := new(Callback)
	ctx.Register(ret)
	return ret
}

// Dispatch dispatches event for object Callback
func (p *Callback) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateCallbackDones) > 0 {
			ev := CallbackDoneEvent{}
			ev.C = p
			ev.CallbackData = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateCallbackDones {
				h.HandleCallbackDone(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// CallbackDoneEvent is the done event
type CallbackDoneEvent struct {
	// CallbackData is the request-specific data for the callback
	CallbackData uint32
	C            *Callback
}

// CallbackDoneHandler is the handler interface for CallbackDoneEvent
type CallbackDoneHandler interface {
	HandleCallbackDone(CallbackDoneEvent)
}

// AddDoneHandler removes the Done handler
func (p *Callback) AddDoneHandler(h CallbackDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateCallbackDones = append(p.privateCallbackDones, h)
		p.mu.Unlock()
	}
}

// RemoveDoneHandler adds the Done handler
func (p *Callback) RemoveDoneHandler(h CallbackDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateCallbackDones {
		if e == h {
			p.privateCallbackDones = append(p.privateCallbackDones[:i], p.privateCallbackDones[i+1:]...)
			break
		}
	}
}

// Compositor the compositor singleton
type Compositor struct {
	BaseProxy
}

// NewCompositor is a constructor for the Compositor object
func NewCompositor(ctx *Context) *Compositor {
	ret := new(Compositor)
	ctx.Register(ret)
	return ret
}

// CreateSurface create new surface
func (p *Compositor) CreateSurface() (*Surface, error) {
	retId := NewSurface(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId)
}

// CreateRegion create new region
func (p *Compositor) CreateRegion() (*Region, error) {
	retId := NewRegion(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}

// Dispatch dispatches event for object Compositor
func (p *Compositor) Dispatch(event *Event) {
	switch event.Opcode {

	}
}

// ShmPool a shared memory pool
type ShmPool struct {
	BaseProxy
}

// NewShmPool is a constructor for the ShmPool object
func NewShmPool(ctx *Context) *ShmPool {
	ret := new(ShmPool)
	ctx.Register(ret)
	return ret
}

// CreateBuffer create a buffer from the pool
func (p *ShmPool) CreateBuffer(Offset int32, Width int32, Height int32, Stride int32, Format uint32) (*Buffer, error) {
	retId := NewBuffer(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId, Offset, Width, Height, Stride, Format)
}

// Destroy destroy the pool
func (p *ShmPool) Destroy() error {

	return p.Context().SendRequest(p, 1)
}

// Resize change the size of the pool mapping
func (p *ShmPool) Resize(Size int32) error {

	return p.Context().SendRequest(p, 2, Size)
}

// Dispatch dispatches event for object ShmPool
func (p *ShmPool) Dispatch(event *Event) {
	switch event.Opcode {

	}
}

// Shm shared memory support
type Shm struct {
	BaseProxy
	mu                sync.RWMutex
	privateShmFormats []ShmFormatHandler
}

// NewShm is a constructor for the Shm object
func NewShm(ctx *Context) *Shm {
	ret := new(Shm)
	ctx.Register(ret)
	return ret
}

// CreatePool create a shm pool
func (p *Shm) CreatePool(Fd uintptr, Size int32) (*ShmPool, error) {
	retId := NewShmPool(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId, Fd, Size)
}

// Release release the shm object
func (p *Shm) Release() error {

	return p.Context().SendRequest(p, 1)
}

// Dispatch dispatches event for object Shm
func (p *Shm) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateShmFormats) > 0 {
			ev := ShmFormatEvent{}
			ev.Format = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateShmFormats {
				h.HandleShmFormat(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// ShmFormatEvent is the pixel format description
type ShmFormatEvent struct {
	// Format is the buffer pixel format
	Format uint32
}

// ShmFormatHandler is the handler interface for ShmFormatEvent
type ShmFormatHandler interface {
	HandleShmFormat(ShmFormatEvent)
}

// AddFormatHandler removes the Format handler
func (p *Shm) AddFormatHandler(h ShmFormatHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShmFormats = append(p.privateShmFormats, h)
		p.mu.Unlock()
	}
}

// RemoveFormatHandler adds the Format handler
func (p *Shm) RemoveFormatHandler(h ShmFormatHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateShmFormats {
		if e == h {
			p.privateShmFormats = append(p.privateShmFormats[:i], p.privateShmFormats[i+1:]...)
			break
		}
	}
}

// Buffer content for a wl_surface
type Buffer struct {
	BaseProxy
	mu                    sync.RWMutex
	privateBufferReleases []BufferReleaseHandler
}

// NewBuffer is a constructor for the Buffer object
func NewBuffer(ctx *Context) *Buffer {
	ret := new(Buffer)
	ctx.Register(ret)
	return ret
}

// Destroy destroy a buffer
func (p *Buffer) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// Dispatch dispatches event for object Buffer
func (p *Buffer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateBufferReleases) > 0 {
			ev := BufferReleaseEvent{}
			ev.B = p
			p.mu.RLock()
			for _, h := range p.privateBufferReleases {
				h.HandleBufferRelease(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// BufferReleaseEvent is the compositor releases buffer
type BufferReleaseEvent struct {
	B *Buffer
}

// BufferReleaseHandler is the handler interface for BufferReleaseEvent
type BufferReleaseHandler interface {
	HandleBufferRelease(BufferReleaseEvent)
}

// AddReleaseHandler removes the Release handler
func (p *Buffer) AddReleaseHandler(h BufferReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateBufferReleases = append(p.privateBufferReleases, h)
		p.mu.Unlock()
	}
}

// RemoveReleaseHandler adds the Release handler
func (p *Buffer) RemoveReleaseHandler(h BufferReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateBufferReleases {
		if e == h {
			p.privateBufferReleases = append(p.privateBufferReleases[:i], p.privateBufferReleases[i+1:]...)
			break
		}
	}
}

// DataOffer offer to transfer data
type DataOffer struct {
	BaseProxy
	mu                             sync.RWMutex
	privateDataOfferOffers         []DataOfferOfferHandler
	privateDataOfferSourceActionss []DataOfferSourceActionsHandler
	privateDataOfferActions        []DataOfferActionHandler
}

// NewDataOffer is a constructor for the DataOffer object
func NewDataOffer(ctx *Context) *DataOffer {
	ret := new(DataOffer)
	ctx.Register(ret)
	return ret
}

// Accept accept one of the offered mime types
func (p *DataOffer) Accept(Serial uint32, MimeType string) error {

	return p.Context().SendRequest(p, 0, Serial, MimeType)
}

// Receive request that the data is transferred
func (p *DataOffer) Receive(MimeType string, Fd uintptr) error {

	return p.Context().SendRequest(p, 1, MimeType, Fd)
}

// Destroy destroy data offer
func (p *DataOffer) Destroy() error {

	return p.Context().SendRequest(p, 2)
}

// Finish the offer will no longer be used
func (p *DataOffer) Finish() error {

	return p.Context().SendRequest(p, 3)
}

// SetActions set the available/preferred drag-and-drop actions
func (p *DataOffer) SetActions(DndActions uint32, PreferredAction uint32) error {

	return p.Context().SendRequest(p, 4, DndActions, PreferredAction)
}

// Dispatch dispatches event for object DataOffer
func (p *DataOffer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDataOfferOffers) > 0 {
			ev := DataOfferOfferEvent{}
			ev.MimeType = event.String()
			p.mu.RLock()
			for _, h := range p.privateDataOfferOffers {
				h.HandleDataOfferOffer(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDataOfferSourceActionss) > 0 {
			ev := DataOfferSourceActionsEvent{}
			ev.SourceActions = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateDataOfferSourceActionss {
				h.HandleDataOfferSourceActions(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateDataOfferActions) > 0 {
			ev := DataOfferActionEvent{}
			ev.DndAction = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateDataOfferActions {
				h.HandleDataOfferAction(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// DataOfferOfferEvent is the advertise offered mime type
type DataOfferOfferEvent struct {
	// MimeType is the offered mime type
	MimeType string
}

// DataOfferSourceActionsEvent is the notify the source-side available actions
type DataOfferSourceActionsEvent struct {
	// SourceActions is the actions offered by the data source
	SourceActions uint32
}

// DataOfferActionEvent is the notify the selected action
type DataOfferActionEvent struct {
	// DndAction is the action selected by the compositor
	DndAction uint32
}

// DataOfferOfferHandler is the handler interface for DataOfferOfferEvent
type DataOfferOfferHandler interface {
	HandleDataOfferOffer(DataOfferOfferEvent)
}

// AddOfferHandler removes the Offer handler
func (p *DataOffer) AddOfferHandler(h DataOfferOfferHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataOfferOffers = append(p.privateDataOfferOffers, h)
		p.mu.Unlock()
	}
}

// RemoveOfferHandler adds the Offer handler
func (p *DataOffer) RemoveOfferHandler(h DataOfferOfferHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataOfferOffers {
		if e == h {
			p.privateDataOfferOffers = append(p.privateDataOfferOffers[:i], p.privateDataOfferOffers[i+1:]...)
			break
		}
	}
}

// DataOfferSourceActionsHandler is the handler interface for DataOfferSourceActionsEvent
type DataOfferSourceActionsHandler interface {
	HandleDataOfferSourceActions(DataOfferSourceActionsEvent)
}

// AddSourceActionsHandler removes the SourceActions handler
func (p *DataOffer) AddSourceActionsHandler(h DataOfferSourceActionsHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataOfferSourceActionss = append(p.privateDataOfferSourceActionss, h)
		p.mu.Unlock()
	}
}

// RemoveSourceActionsHandler adds the SourceActions handler
func (p *DataOffer) RemoveSourceActionsHandler(h DataOfferSourceActionsHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataOfferSourceActionss {
		if e == h {
			p.privateDataOfferSourceActionss = append(p.privateDataOfferSourceActionss[:i], p.privateDataOfferSourceActionss[i+1:]...)
			break
		}
	}
}

// DataOfferActionHandler is the handler interface for DataOfferActionEvent
type DataOfferActionHandler interface {
	HandleDataOfferAction(DataOfferActionEvent)
}

// AddActionHandler removes the Action handler
func (p *DataOffer) AddActionHandler(h DataOfferActionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataOfferActions = append(p.privateDataOfferActions, h)
		p.mu.Unlock()
	}
}

// RemoveActionHandler adds the Action handler
func (p *DataOffer) RemoveActionHandler(h DataOfferActionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataOfferActions {
		if e == h {
			p.privateDataOfferActions = append(p.privateDataOfferActions[:i], p.privateDataOfferActions[i+1:]...)
			break
		}
	}
}

// DataSource offer to transfer data
type DataSource struct {
	BaseProxy
	mu                                 sync.RWMutex
	privateDataSourceTargets           []DataSourceTargetHandler
	privateDataSourceSends             []DataSourceSendHandler
	privateDataSourceCancelleds        []DataSourceCancelledHandler
	privateDataSourceDndDropPerformeds []DataSourceDndDropPerformedHandler
	privateDataSourceDndFinisheds      []DataSourceDndFinishedHandler
	privateDataSourceActions           []DataSourceActionHandler
}

// NewDataSource is a constructor for the DataSource object
func NewDataSource(ctx *Context) *DataSource {
	ret := new(DataSource)
	ctx.Register(ret)
	return ret
}

// Offer add an offered mime type
func (p *DataSource) Offer(MimeType string) error {

	return p.Context().SendRequest(p, 0, MimeType)
}

// Destroy destroy the data source
func (p *DataSource) Destroy() error {

	return p.Context().SendRequest(p, 1)
}

// SetActions set the available drag-and-drop actions
func (p *DataSource) SetActions(DndActions uint32) error {

	return p.Context().SendRequest(p, 2, DndActions)
}

// Dispatch dispatches event for object DataSource
func (p *DataSource) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDataSourceTargets) > 0 {
			ev := DataSourceTargetEvent{}
			ev.MimeType = event.String()
			p.mu.RLock()
			for _, h := range p.privateDataSourceTargets {
				h.HandleDataSourceTarget(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDataSourceSends) > 0 {
			ev := DataSourceSendEvent{}
			ev.MimeType = event.String()
			ev.Fd, ev.FdError = event.FD()
			p.mu.RLock()
			for _, h := range p.privateDataSourceSends {
				h.HandleDataSourceSend(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateDataSourceCancelleds) > 0 {
			ev := DataSourceCancelledEvent{}
			p.mu.RLock()
			for _, h := range p.privateDataSourceCancelleds {
				h.HandleDataSourceCancelled(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateDataSourceDndDropPerformeds) > 0 {
			ev := DataSourceDndDropPerformedEvent{}
			p.mu.RLock()
			for _, h := range p.privateDataSourceDndDropPerformeds {
				h.HandleDataSourceDndDropPerformed(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateDataSourceDndFinisheds) > 0 {
			ev := DataSourceDndFinishedEvent{}
			p.mu.RLock()
			for _, h := range p.privateDataSourceDndFinisheds {
				h.HandleDataSourceDndFinished(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateDataSourceActions) > 0 {
			ev := DataSourceActionEvent{}
			ev.DndAction = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateDataSourceActions {
				h.HandleDataSourceAction(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// DataSourceTargetEvent is the a target accepts an offered mime type
type DataSourceTargetEvent struct {
	// MimeType is the mime type accepted by the target
	MimeType string
}

// DataSourceSendEvent is the send the data
type DataSourceSendEvent struct {
	// MimeType is the mime type for the data
	MimeType string
	// Fd is the file descriptor for the data
	Fd uintptr
	// FdError is the file descriptor for the data (error)
	FdError error
}

// DataSourceCancelledEvent is the selection was cancelled
type DataSourceCancelledEvent struct {
}

// DataSourceDndDropPerformedEvent is the the drag-and-drop operation physically finished
type DataSourceDndDropPerformedEvent struct {
}

// DataSourceDndFinishedEvent is the the drag-and-drop operation concluded
type DataSourceDndFinishedEvent struct {
}

// DataSourceActionEvent is the notify the selected action
type DataSourceActionEvent struct {
	// DndAction is the action selected by the compositor
	DndAction uint32
}

// DataSourceTargetHandler is the handler interface for DataSourceTargetEvent
type DataSourceTargetHandler interface {
	HandleDataSourceTarget(DataSourceTargetEvent)
}

// AddTargetHandler removes the Target handler
func (p *DataSource) AddTargetHandler(h DataSourceTargetHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceTargets = append(p.privateDataSourceTargets, h)
		p.mu.Unlock()
	}
}

// RemoveTargetHandler adds the Target handler
func (p *DataSource) RemoveTargetHandler(h DataSourceTargetHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataSourceTargets {
		if e == h {
			p.privateDataSourceTargets = append(p.privateDataSourceTargets[:i], p.privateDataSourceTargets[i+1:]...)
			break
		}
	}
}

// DataSourceSendHandler is the handler interface for DataSourceSendEvent
type DataSourceSendHandler interface {
	HandleDataSourceSend(DataSourceSendEvent)
}

// AddSendHandler removes the Send handler
func (p *DataSource) AddSendHandler(h DataSourceSendHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceSends = append(p.privateDataSourceSends, h)
		p.mu.Unlock()
	}
}

// RemoveSendHandler adds the Send handler
func (p *DataSource) RemoveSendHandler(h DataSourceSendHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataSourceSends {
		if e == h {
			p.privateDataSourceSends = append(p.privateDataSourceSends[:i], p.privateDataSourceSends[i+1:]...)
			break
		}
	}
}

// DataSourceCancelledHandler is the handler interface for DataSourceCancelledEvent
type DataSourceCancelledHandler interface {
	HandleDataSourceCancelled(DataSourceCancelledEvent)
}

// AddCancelledHandler removes the Cancelled handler
func (p *DataSource) AddCancelledHandler(h DataSourceCancelledHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceCancelleds = append(p.privateDataSourceCancelleds, h)
		p.mu.Unlock()
	}
}

// RemoveCancelledHandler adds the Cancelled handler
func (p *DataSource) RemoveCancelledHandler(h DataSourceCancelledHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataSourceCancelleds {
		if e == h {
			p.privateDataSourceCancelleds = append(p.privateDataSourceCancelleds[:i], p.privateDataSourceCancelleds[i+1:]...)
			break
		}
	}
}

// DataSourceDndDropPerformedHandler is the handler interface for DataSourceDndDropPerformedEvent
type DataSourceDndDropPerformedHandler interface {
	HandleDataSourceDndDropPerformed(DataSourceDndDropPerformedEvent)
}

// AddDndDropPerformedHandler removes the DndDropPerformed handler
func (p *DataSource) AddDndDropPerformedHandler(h DataSourceDndDropPerformedHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceDndDropPerformeds = append(p.privateDataSourceDndDropPerformeds, h)
		p.mu.Unlock()
	}
}

// RemoveDndDropPerformedHandler adds the DndDropPerformed handler
func (p *DataSource) RemoveDndDropPerformedHandler(h DataSourceDndDropPerformedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataSourceDndDropPerformeds {
		if e == h {
			p.privateDataSourceDndDropPerformeds = append(p.privateDataSourceDndDropPerformeds[:i], p.privateDataSourceDndDropPerformeds[i+1:]...)
			break
		}
	}
}

// DataSourceDndFinishedHandler is the handler interface for DataSourceDndFinishedEvent
type DataSourceDndFinishedHandler interface {
	HandleDataSourceDndFinished(DataSourceDndFinishedEvent)
}

// AddDndFinishedHandler removes the DndFinished handler
func (p *DataSource) AddDndFinishedHandler(h DataSourceDndFinishedHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceDndFinisheds = append(p.privateDataSourceDndFinisheds, h)
		p.mu.Unlock()
	}
}

// RemoveDndFinishedHandler adds the DndFinished handler
func (p *DataSource) RemoveDndFinishedHandler(h DataSourceDndFinishedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataSourceDndFinisheds {
		if e == h {
			p.privateDataSourceDndFinisheds = append(p.privateDataSourceDndFinisheds[:i], p.privateDataSourceDndFinisheds[i+1:]...)
			break
		}
	}
}

// DataSourceActionHandler is the handler interface for DataSourceActionEvent
type DataSourceActionHandler interface {
	HandleDataSourceAction(DataSourceActionEvent)
}

// AddActionHandler removes the Action handler
func (p *DataSource) AddActionHandler(h DataSourceActionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceActions = append(p.privateDataSourceActions, h)
		p.mu.Unlock()
	}
}

// RemoveActionHandler adds the Action handler
func (p *DataSource) RemoveActionHandler(h DataSourceActionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataSourceActions {
		if e == h {
			p.privateDataSourceActions = append(p.privateDataSourceActions[:i], p.privateDataSourceActions[i+1:]...)
			break
		}
	}
}

// DataDevice data transfer device
type DataDevice struct {
	BaseProxy
	mu                          sync.RWMutex
	privateDataDeviceDataOffers []DataDeviceDataOfferHandler
	privateDataDeviceEnters     []DataDeviceEnterHandler
	privateDataDeviceLeaves     []DataDeviceLeaveHandler
	privateDataDeviceMotions    []DataDeviceMotionHandler
	privateDataDeviceDrops      []DataDeviceDropHandler
	privateDataDeviceSelections []DataDeviceSelectionHandler
}

// NewDataDevice is a constructor for the DataDevice object
func NewDataDevice(ctx *Context) *DataDevice {
	ret := new(DataDevice)
	ctx.Register(ret)
	return ret
}

// StartDrag start drag-and-drop operation
func (p *DataDevice) StartDrag(Source *DataSource, Origin *Surface, Icon *Surface, Serial uint32) error {

	return p.Context().SendRequest(p, 0, Source, Origin, Icon, Serial)
}

// SetSelection copy data to the selection
func (p *DataDevice) SetSelection(Source *DataSource, Serial uint32) error {

	return p.Context().SendRequest(p, 1, Source, Serial)
}

// Release destroy data device
func (p *DataDevice) Release() error {

	return p.Context().SendRequest(p, 2)
}

// Dispatch dispatches event for object DataDevice
func (p *DataDevice) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDataDeviceDataOffers) > 0 {
			ev := DataDeviceDataOfferEvent{}
			ev.Id = event.NewId(new(DataOffer), p.Context()).(*DataOffer)
			p.mu.RLock()
			for _, h := range p.privateDataDeviceDataOffers {
				h.HandleDataDeviceDataOffer(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDataDeviceEnters) > 0 {
			ev := DataDeviceEnterEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			ev.X = event.Float32()
			ev.Y = event.Float32()
			ev.Id = event.Proxy(p.Context()).(*DataOffer)
			p.mu.RLock()
			for _, h := range p.privateDataDeviceEnters {
				h.HandleDataDeviceEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateDataDeviceLeaves) > 0 {
			ev := DataDeviceLeaveEvent{}
			p.mu.RLock()
			for _, h := range p.privateDataDeviceLeaves {
				h.HandleDataDeviceLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateDataDeviceMotions) > 0 {
			ev := DataDeviceMotionEvent{}
			ev.Time = event.Uint32()
			ev.X = event.Float32()
			ev.Y = event.Float32()
			p.mu.RLock()
			for _, h := range p.privateDataDeviceMotions {
				h.HandleDataDeviceMotion(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateDataDeviceDrops) > 0 {
			ev := DataDeviceDropEvent{}
			p.mu.RLock()
			for _, h := range p.privateDataDeviceDrops {
				h.HandleDataDeviceDrop(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateDataDeviceSelections) > 0 {
			ev := DataDeviceSelectionEvent{}
			ev.Id = event.Proxy(p.Context()).(*DataOffer)
			p.mu.RLock()
			for _, h := range p.privateDataDeviceSelections {
				h.HandleDataDeviceSelection(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// DataDeviceDataOfferEvent is the introduce a new wl_data_offer
type DataDeviceDataOfferEvent struct {
	// Id is the the new data_offer object
	Id *DataOffer
}

// DataDeviceEnterEvent is the initiate drag-and-drop session
type DataDeviceEnterEvent struct {
	// Serial is the serial number of the enter event
	Serial uint32
	// Surface is the client surface entered
	Surface *Surface
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32
	// Id is the source data_offer object
	Id *DataOffer
}

// DataDeviceLeaveEvent is the end drag-and-drop session
type DataDeviceLeaveEvent struct {
}

// DataDeviceMotionEvent is the drag-and-drop session motion
type DataDeviceMotionEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32
}

// DataDeviceDropEvent is the end drag-and-drop session successfully
type DataDeviceDropEvent struct {
}

// DataDeviceSelectionEvent is the advertise new selection
type DataDeviceSelectionEvent struct {
	// Id is the selection data_offer object
	Id *DataOffer
}

// DataDeviceDataOfferHandler is the handler interface for DataDeviceDataOfferEvent
type DataDeviceDataOfferHandler interface {
	HandleDataDeviceDataOffer(DataDeviceDataOfferEvent)
}

// AddDataOfferHandler removes the DataOffer handler
func (p *DataDevice) AddDataOfferHandler(h DataDeviceDataOfferHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceDataOffers = append(p.privateDataDeviceDataOffers, h)
		p.mu.Unlock()
	}
}

// RemoveDataOfferHandler adds the DataOffer handler
func (p *DataDevice) RemoveDataOfferHandler(h DataDeviceDataOfferHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataDeviceDataOffers {
		if e == h {
			p.privateDataDeviceDataOffers = append(p.privateDataDeviceDataOffers[:i], p.privateDataDeviceDataOffers[i+1:]...)
			break
		}
	}
}

// DataDeviceEnterHandler is the handler interface for DataDeviceEnterEvent
type DataDeviceEnterHandler interface {
	HandleDataDeviceEnter(DataDeviceEnterEvent)
}

// AddEnterHandler removes the Enter handler
func (p *DataDevice) AddEnterHandler(h DataDeviceEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceEnters = append(p.privateDataDeviceEnters, h)
		p.mu.Unlock()
	}
}

// RemoveEnterHandler adds the Enter handler
func (p *DataDevice) RemoveEnterHandler(h DataDeviceEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataDeviceEnters {
		if e == h {
			p.privateDataDeviceEnters = append(p.privateDataDeviceEnters[:i], p.privateDataDeviceEnters[i+1:]...)
			break
		}
	}
}

// DataDeviceLeaveHandler is the handler interface for DataDeviceLeaveEvent
type DataDeviceLeaveHandler interface {
	HandleDataDeviceLeave(DataDeviceLeaveEvent)
}

// AddLeaveHandler removes the Leave handler
func (p *DataDevice) AddLeaveHandler(h DataDeviceLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceLeaves = append(p.privateDataDeviceLeaves, h)
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler adds the Leave handler
func (p *DataDevice) RemoveLeaveHandler(h DataDeviceLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataDeviceLeaves {
		if e == h {
			p.privateDataDeviceLeaves = append(p.privateDataDeviceLeaves[:i], p.privateDataDeviceLeaves[i+1:]...)
			break
		}
	}
}

// DataDeviceMotionHandler is the handler interface for DataDeviceMotionEvent
type DataDeviceMotionHandler interface {
	HandleDataDeviceMotion(DataDeviceMotionEvent)
}

// AddMotionHandler removes the Motion handler
func (p *DataDevice) AddMotionHandler(h DataDeviceMotionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceMotions = append(p.privateDataDeviceMotions, h)
		p.mu.Unlock()
	}
}

// RemoveMotionHandler adds the Motion handler
func (p *DataDevice) RemoveMotionHandler(h DataDeviceMotionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataDeviceMotions {
		if e == h {
			p.privateDataDeviceMotions = append(p.privateDataDeviceMotions[:i], p.privateDataDeviceMotions[i+1:]...)
			break
		}
	}
}

// DataDeviceDropHandler is the handler interface for DataDeviceDropEvent
type DataDeviceDropHandler interface {
	HandleDataDeviceDrop(DataDeviceDropEvent)
}

// AddDropHandler removes the Drop handler
func (p *DataDevice) AddDropHandler(h DataDeviceDropHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceDrops = append(p.privateDataDeviceDrops, h)
		p.mu.Unlock()
	}
}

// RemoveDropHandler adds the Drop handler
func (p *DataDevice) RemoveDropHandler(h DataDeviceDropHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataDeviceDrops {
		if e == h {
			p.privateDataDeviceDrops = append(p.privateDataDeviceDrops[:i], p.privateDataDeviceDrops[i+1:]...)
			break
		}
	}
}

// DataDeviceSelectionHandler is the handler interface for DataDeviceSelectionEvent
type DataDeviceSelectionHandler interface {
	HandleDataDeviceSelection(DataDeviceSelectionEvent)
}

// AddSelectionHandler removes the Selection handler
func (p *DataDevice) AddSelectionHandler(h DataDeviceSelectionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceSelections = append(p.privateDataDeviceSelections, h)
		p.mu.Unlock()
	}
}

// RemoveSelectionHandler adds the Selection handler
func (p *DataDevice) RemoveSelectionHandler(h DataDeviceSelectionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateDataDeviceSelections {
		if e == h {
			p.privateDataDeviceSelections = append(p.privateDataDeviceSelections[:i], p.privateDataDeviceSelections[i+1:]...)
			break
		}
	}
}

// DataDeviceManager data transfer interface
type DataDeviceManager struct {
	BaseProxy
}

// NewDataDeviceManager is a constructor for the DataDeviceManager object
func NewDataDeviceManager(ctx *Context) *DataDeviceManager {
	ret := new(DataDeviceManager)
	ctx.Register(ret)
	return ret
}

// CreateDataSource create a new data source
func (p *DataDeviceManager) CreateDataSource() (*DataSource, error) {
	retId := NewDataSource(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId)
}

// GetDataDevice create a new data device
func (p *DataDeviceManager) GetDataDevice(Seat *Seat) (*DataDevice, error) {
	retId := NewDataDevice(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId, Seat)
}

// Dispatch dispatches event for object DataDeviceManager
func (p *DataDeviceManager) Dispatch(event *Event) {
	switch event.Opcode {

	}
}

// Shell create desktop-style surfaces
type Shell struct {
	BaseProxy
}

// NewShell is a constructor for the Shell object
func NewShell(ctx *Context) *Shell {
	ret := new(Shell)
	ctx.Register(ret)
	return ret
}

// GetShellSurface create a shell surface from a surface
func (p *Shell) GetShellSurface(Surface *Surface) (*ShellSurface, error) {
	retId := NewShellSurface(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId, Surface)
}

// Dispatch dispatches event for object Shell
func (p *Shell) Dispatch(event *Event) {
	switch event.Opcode {

	}
}

// ShellSurface desktop-style metadata interface
type ShellSurface struct {
	BaseProxy
	mu                            sync.RWMutex
	privateShellSurfacePings      []ShellSurfacePingHandler
	privateShellSurfaceConfigures []ShellSurfaceConfigureHandler
	privateShellSurfacePopupDones []ShellSurfacePopupDoneHandler
}

// NewShellSurface is a constructor for the ShellSurface object
func NewShellSurface(ctx *Context) *ShellSurface {
	ret := new(ShellSurface)
	ctx.Register(ret)
	return ret
}

// Pong respond to a ping event
func (p *ShellSurface) Pong(Serial uint32) error {

	return p.Context().SendRequest(p, 0, Serial)
}

// Move start an interactive move
func (p *ShellSurface) Move(Seat *Seat, Serial uint32) error {

	return p.Context().SendRequest(p, 1, Seat, Serial)
}

// Resize start an interactive resize
func (p *ShellSurface) Resize(Seat *Seat, Serial uint32, Edges uint32) error {

	return p.Context().SendRequest(p, 2, Seat, Serial, Edges)
}

// SetToplevel make the surface a toplevel surface
func (p *ShellSurface) SetToplevel() error {

	return p.Context().SendRequest(p, 3)
}

// SetTransient make the surface a transient surface
func (p *ShellSurface) SetTransient(Parent *Surface, X int32, Y int32, Flags uint32) error {

	return p.Context().SendRequest(p, 4, Parent, X, Y, Flags)
}

// SetFullscreen make the surface a fullscreen surface
func (p *ShellSurface) SetFullscreen(Method uint32, Framerate uint32, Output *Output) error {

	return p.Context().SendRequest(p, 5, Method, Framerate, Output)
}

// SetPopup make the surface a popup surface
func (p *ShellSurface) SetPopup(Seat *Seat, Serial uint32, Parent *Surface, X int32, Y int32, Flags uint32) error {

	return p.Context().SendRequest(p, 6, Seat, Serial, Parent, X, Y, Flags)
}

// SetMaximized make the surface a maximized surface
func (p *ShellSurface) SetMaximized(Output *Output) error {

	return p.Context().SendRequest(p, 7, Output)
}

// SetTitle set surface title
func (p *ShellSurface) SetTitle(Title string) error {

	return p.Context().SendRequest(p, 8, Title)
}

// SetClass set surface class
func (p *ShellSurface) SetClass(Class string) error {

	return p.Context().SendRequest(p, 9, Class)
}

// Dispatch dispatches event for object ShellSurface
func (p *ShellSurface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateShellSurfacePings) > 0 {
			ev := ShellSurfacePingEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateShellSurfacePings {
				h.HandleShellSurfacePing(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateShellSurfaceConfigures) > 0 {
			ev := ShellSurfaceConfigureEvent{}
			ev.Edges = event.Uint32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateShellSurfaceConfigures {
				h.HandleShellSurfaceConfigure(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateShellSurfacePopupDones) > 0 {
			ev := ShellSurfacePopupDoneEvent{}
			p.mu.RLock()
			for _, h := range p.privateShellSurfacePopupDones {
				h.HandleShellSurfacePopupDone(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// ShellSurfacePingEvent is the ping client
type ShellSurfacePingEvent struct {
	// Serial is the serial number of the ping
	Serial uint32
}

// ShellSurfaceConfigureEvent is the suggest resize
type ShellSurfaceConfigureEvent struct {
	// Edges is the how the surface was resized
	Edges uint32
	// Width is the new width of the surface
	Width int32
	// Height is the new height of the surface
	Height int32
}

// ShellSurfacePopupDoneEvent is the popup interaction is done
type ShellSurfacePopupDoneEvent struct {
}

// ShellSurfacePingHandler is the handler interface for ShellSurfacePingEvent
type ShellSurfacePingHandler interface {
	HandleShellSurfacePing(ShellSurfacePingEvent)
}

// AddPingHandler removes the Ping handler
func (p *ShellSurface) AddPingHandler(h ShellSurfacePingHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShellSurfacePings = append(p.privateShellSurfacePings, h)
		p.mu.Unlock()
	}
}

// RemovePingHandler adds the Ping handler
func (p *ShellSurface) RemovePingHandler(h ShellSurfacePingHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateShellSurfacePings {
		if e == h {
			p.privateShellSurfacePings = append(p.privateShellSurfacePings[:i], p.privateShellSurfacePings[i+1:]...)
			break
		}
	}
}

// ShellSurfaceConfigureHandler is the handler interface for ShellSurfaceConfigureEvent
type ShellSurfaceConfigureHandler interface {
	HandleShellSurfaceConfigure(ShellSurfaceConfigureEvent)
}

// AddConfigureHandler removes the Configure handler
func (p *ShellSurface) AddConfigureHandler(h ShellSurfaceConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShellSurfaceConfigures = append(p.privateShellSurfaceConfigures, h)
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler adds the Configure handler
func (p *ShellSurface) RemoveConfigureHandler(h ShellSurfaceConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateShellSurfaceConfigures {
		if e == h {
			p.privateShellSurfaceConfigures = append(p.privateShellSurfaceConfigures[:i], p.privateShellSurfaceConfigures[i+1:]...)
			break
		}
	}
}

// ShellSurfacePopupDoneHandler is the handler interface for ShellSurfacePopupDoneEvent
type ShellSurfacePopupDoneHandler interface {
	HandleShellSurfacePopupDone(ShellSurfacePopupDoneEvent)
}

// AddPopupDoneHandler removes the PopupDone handler
func (p *ShellSurface) AddPopupDoneHandler(h ShellSurfacePopupDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShellSurfacePopupDones = append(p.privateShellSurfacePopupDones, h)
		p.mu.Unlock()
	}
}

// RemovePopupDoneHandler adds the PopupDone handler
func (p *ShellSurface) RemovePopupDoneHandler(h ShellSurfacePopupDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateShellSurfacePopupDones {
		if e == h {
			p.privateShellSurfacePopupDones = append(p.privateShellSurfacePopupDones[:i], p.privateShellSurfacePopupDones[i+1:]...)
			break
		}
	}
}

// Surface an onscreen surface
type Surface struct {
	BaseProxy
	mu                                      sync.RWMutex
	privateSurfaceEnters                    []SurfaceEnterHandler
	privateSurfaceLeaves                    []SurfaceLeaveHandler
	privateSurfacePreferredBufferScales     []SurfacePreferredBufferScaleHandler
	privateSurfacePreferredBufferTransforms []SurfacePreferredBufferTransformHandler
}

// NewSurface is a constructor for the Surface object
func NewSurface(ctx *Context) *Surface {
	ret := new(Surface)
	ctx.Register(ret)
	return ret
}

// Destroy delete surface
func (p *Surface) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// Attach set the surface contents
func (p *Surface) Attach(Buffer *Buffer, X int32, Y int32) error {

	return p.Context().SendRequest(p, 1, Buffer, X, Y)
}

// Damage mark part of the surface damaged
func (p *Surface) Damage(X int32, Y int32, Width int32, Height int32) error {

	return p.Context().SendRequest(p, 2, X, Y, Width, Height)
}

// Frame request a frame throttling hint
func (p *Surface) Frame() (*Callback, error) {
	retCallback := NewCallback(p.Context())
	return retCallback, p.Context().SendRequest(p, 3, retCallback)
}

// SetOpaqueRegion set opaque region
func (p *Surface) SetOpaqueRegion(Region *Region) error {

	return p.Context().SendRequest(p, 4, Region)
}

// SetInputRegion set input region
func (p *Surface) SetInputRegion(Region *Region) error {

	return p.Context().SendRequest(p, 5, Region)
}

// Commit commit pending surface state
func (p *Surface) Commit() error {

	return p.Context().SendRequest(p, 6)
}

// SetBufferTransform sets the buffer transformation
func (p *Surface) SetBufferTransform(Transform int32) error {

	return p.Context().SendRequest(p, 7, Transform)
}

// SetBufferScale sets the buffer scaling factor
func (p *Surface) SetBufferScale(Scale int32) error {

	return p.Context().SendRequest(p, 8, Scale)
}

// DamageBuffer mark part of the surface damaged using buffer coordinates
func (p *Surface) DamageBuffer(X int32, Y int32, Width int32, Height int32) error {

	return p.Context().SendRequest(p, 9, X, Y, Width, Height)
}

// Offset set the surface contents offset
func (p *Surface) Offset(X int32, Y int32) error {

	return p.Context().SendRequest(p, 10, X, Y)
}

// Dispatch dispatches event for object Surface
func (p *Surface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateSurfaceEnters) > 0 {
			ev := SurfaceEnterEvent{}
			ev.Output = event.Proxy(p.Context()).(*Output)
			p.mu.RLock()
			for _, h := range p.privateSurfaceEnters {
				h.HandleSurfaceEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateSurfaceLeaves) > 0 {
			ev := SurfaceLeaveEvent{}
			ev.Output = event.Proxy(p.Context()).(*Output)
			p.mu.RLock()
			for _, h := range p.privateSurfaceLeaves {
				h.HandleSurfaceLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateSurfacePreferredBufferScales) > 0 {
			ev := SurfacePreferredBufferScaleEvent{}
			ev.Factor = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateSurfacePreferredBufferScales {
				h.HandleSurfacePreferredBufferScale(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateSurfacePreferredBufferTransforms) > 0 {
			ev := SurfacePreferredBufferTransformEvent{}
			ev.Transform = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateSurfacePreferredBufferTransforms {
				h.HandleSurfacePreferredBufferTransform(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// SurfaceEnterEvent is the surface enters an output
type SurfaceEnterEvent struct {
	// Output is the output entered by the surface
	Output *Output
}

// SurfaceLeaveEvent is the surface leaves an output
type SurfaceLeaveEvent struct {
	// Output is the output left by the surface
	Output *Output
}

// SurfacePreferredBufferScaleEvent is the preferred buffer scale for the surface
type SurfacePreferredBufferScaleEvent struct {
	// Factor is the preferred scaling factor
	Factor int32
}

// SurfacePreferredBufferTransformEvent is the preferred buffer transform for the surface
type SurfacePreferredBufferTransformEvent struct {
	// Transform is the preferred transform
	Transform uint32
}

// SurfaceEnterHandler is the handler interface for SurfaceEnterEvent
type SurfaceEnterHandler interface {
	HandleSurfaceEnter(SurfaceEnterEvent)
}

// AddEnterHandler removes the Enter handler
func (p *Surface) AddEnterHandler(h SurfaceEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfaceEnters = append(p.privateSurfaceEnters, h)
		p.mu.Unlock()
	}
}

// RemoveEnterHandler adds the Enter handler
func (p *Surface) RemoveEnterHandler(h SurfaceEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateSurfaceEnters {
		if e == h {
			p.privateSurfaceEnters = append(p.privateSurfaceEnters[:i], p.privateSurfaceEnters[i+1:]...)
			break
		}
	}
}

// SurfaceLeaveHandler is the handler interface for SurfaceLeaveEvent
type SurfaceLeaveHandler interface {
	HandleSurfaceLeave(SurfaceLeaveEvent)
}

// AddLeaveHandler removes the Leave handler
func (p *Surface) AddLeaveHandler(h SurfaceLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfaceLeaves = append(p.privateSurfaceLeaves, h)
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler adds the Leave handler
func (p *Surface) RemoveLeaveHandler(h SurfaceLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateSurfaceLeaves {
		if e == h {
			p.privateSurfaceLeaves = append(p.privateSurfaceLeaves[:i], p.privateSurfaceLeaves[i+1:]...)
			break
		}
	}
}

// SurfacePreferredBufferScaleHandler is the handler interface for SurfacePreferredBufferScaleEvent
type SurfacePreferredBufferScaleHandler interface {
	HandleSurfacePreferredBufferScale(SurfacePreferredBufferScaleEvent)
}

// AddPreferredBufferScaleHandler removes the PreferredBufferScale handler
func (p *Surface) AddPreferredBufferScaleHandler(h SurfacePreferredBufferScaleHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfacePreferredBufferScales = append(p.privateSurfacePreferredBufferScales, h)
		p.mu.Unlock()
	}
}

// RemovePreferredBufferScaleHandler adds the PreferredBufferScale handler
func (p *Surface) RemovePreferredBufferScaleHandler(h SurfacePreferredBufferScaleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateSurfacePreferredBufferScales {
		if e == h {
			p.privateSurfacePreferredBufferScales = append(p.privateSurfacePreferredBufferScales[:i], p.privateSurfacePreferredBufferScales[i+1:]...)
			break
		}
	}
}

// SurfacePreferredBufferTransformHandler is the handler interface for SurfacePreferredBufferTransformEvent
type SurfacePreferredBufferTransformHandler interface {
	HandleSurfacePreferredBufferTransform(SurfacePreferredBufferTransformEvent)
}

// AddPreferredBufferTransformHandler removes the PreferredBufferTransform handler
func (p *Surface) AddPreferredBufferTransformHandler(h SurfacePreferredBufferTransformHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfacePreferredBufferTransforms = append(p.privateSurfacePreferredBufferTransforms, h)
		p.mu.Unlock()
	}
}

// RemovePreferredBufferTransformHandler adds the PreferredBufferTransform handler
func (p *Surface) RemovePreferredBufferTransformHandler(h SurfacePreferredBufferTransformHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateSurfacePreferredBufferTransforms {
		if e == h {
			p.privateSurfacePreferredBufferTransforms = append(p.privateSurfacePreferredBufferTransforms[:i], p.privateSurfacePreferredBufferTransforms[i+1:]...)
			break
		}
	}
}

// Seat group of input devices
type Seat struct {
	BaseProxy
	mu                       sync.RWMutex
	privateSeatCapabilitiess []SeatCapabilitiesHandler
	privateSeatNames         []SeatNameHandler
}

// NewSeat is a constructor for the Seat object
func NewSeat(ctx *Context) *Seat {
	ret := new(Seat)
	ctx.Register(ret)
	return ret
}

// GetPointer return pointer object
func (p *Seat) GetPointer() (*Pointer, error) {
	retId := NewPointer(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId)
}

// GetKeyboard return keyboard object
func (p *Seat) GetKeyboard() (*Keyboard, error) {
	retId := NewKeyboard(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}

// GetTouch return touch object
func (p *Seat) GetTouch() (*Touch, error) {
	retId := NewTouch(p.Context())
	return retId, p.Context().SendRequest(p, 2, retId)
}

// Release release the seat object
func (p *Seat) Release() error {

	return p.Context().SendRequest(p, 3)
}

// Dispatch dispatches event for object Seat
func (p *Seat) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateSeatCapabilitiess) > 0 {
			ev := SeatCapabilitiesEvent{}
			ev.Capabilities = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateSeatCapabilitiess {
				h.HandleSeatCapabilities(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateSeatNames) > 0 {
			ev := SeatNameEvent{}
			ev.Name = event.String()
			p.mu.RLock()
			for _, h := range p.privateSeatNames {
				h.HandleSeatName(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// SeatCapabilitiesEvent is the seat capabilities changed
type SeatCapabilitiesEvent struct {
	// Capabilities is the capabilities of the seat
	Capabilities uint32
}

// SeatNameEvent is the unique identifier for this seat
type SeatNameEvent struct {
	// Name is the seat identifier
	Name string
}

// SeatCapabilitiesHandler is the handler interface for SeatCapabilitiesEvent
type SeatCapabilitiesHandler interface {
	HandleSeatCapabilities(SeatCapabilitiesEvent)
}

// AddCapabilitiesHandler removes the Capabilities handler
func (p *Seat) AddCapabilitiesHandler(h SeatCapabilitiesHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSeatCapabilitiess = append(p.privateSeatCapabilitiess, h)
		p.mu.Unlock()
	}
}

// RemoveCapabilitiesHandler adds the Capabilities handler
func (p *Seat) RemoveCapabilitiesHandler(h SeatCapabilitiesHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateSeatCapabilitiess {
		if e == h {
			p.privateSeatCapabilitiess = append(p.privateSeatCapabilitiess[:i], p.privateSeatCapabilitiess[i+1:]...)
			break
		}
	}
}

// SeatNameHandler is the handler interface for SeatNameEvent
type SeatNameHandler interface {
	HandleSeatName(SeatNameEvent)
}

// AddNameHandler removes the Name handler
func (p *Seat) AddNameHandler(h SeatNameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSeatNames = append(p.privateSeatNames, h)
		p.mu.Unlock()
	}
}

// RemoveNameHandler adds the Name handler
func (p *Seat) RemoveNameHandler(h SeatNameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateSeatNames {
		if e == h {
			p.privateSeatNames = append(p.privateSeatNames[:i], p.privateSeatNames[i+1:]...)
			break
		}
	}
}

// Pointer pointer input device
type Pointer struct {
	BaseProxy
	mu                                   sync.RWMutex
	privatePointerEnters                 []PointerEnterHandler
	privatePointerLeaves                 []PointerLeaveHandler
	privatePointerMotions                []PointerMotionHandler
	privatePointerButtons                []PointerButtonHandler
	privatePointerAxiss                  []PointerAxisHandler
	privatePointerFrames                 []PointerFrameHandler
	privatePointerAxisSources            []PointerAxisSourceHandler
	privatePointerAxisStops              []PointerAxisStopHandler
	privatePointerAxisDiscretes          []PointerAxisDiscreteHandler
	privatePointerAxisValue120s          []PointerAxisValue120Handler
	privatePointerAxisRelativeDirections []PointerAxisRelativeDirectionHandler
}

// NewPointer is a constructor for the Pointer object
func NewPointer(ctx *Context) *Pointer {
	ret := new(Pointer)
	ctx.Register(ret)
	return ret
}

// SetCursor set the pointer surface
func (p *Pointer) SetCursor(Serial uint32, Surface *Surface, HotspotX int32, HotspotY int32) error {

	return p.Context().SendRequest(p, 0, Serial, Surface, HotspotX, HotspotY)
}

// Release release the pointer object
func (p *Pointer) Release() error {

	return p.Context().SendRequest(p, 1)
}

// Dispatch dispatches event for object Pointer
func (p *Pointer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privatePointerEnters) > 0 {
			ev := PointerEnterEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			ev.SurfaceX = event.Float32()
			ev.SurfaceY = event.Float32()
			p.mu.RLock()
			for _, h := range p.privatePointerEnters {
				h.HandlePointerEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privatePointerLeaves) > 0 {
			ev := PointerLeaveEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			p.mu.RLock()
			for _, h := range p.privatePointerLeaves {
				h.HandlePointerLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privatePointerMotions) > 0 {
			ev := PointerMotionEvent{}
			ev.P = p
			ev.Time = event.Uint32()
			ev.SurfaceX = event.Float32()
			ev.SurfaceY = event.Float32()
			p.mu.RLock()
			for _, h := range p.privatePointerMotions {
				h.HandlePointerMotion(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privatePointerButtons) > 0 {
			ev := PointerButtonEvent{}
			ev.P = p
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Button = event.Uint32()
			ev.State = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privatePointerButtons {
				h.HandlePointerButton(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privatePointerAxiss) > 0 {
			ev := PointerAxisEvent{}
			ev.Time = event.Uint32()
			ev.Axis = event.Uint32()
			ev.Value = event.Float32()
			p.mu.RLock()
			for _, h := range p.privatePointerAxiss {
				h.HandlePointerAxis(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privatePointerFrames) > 0 {
			ev := PointerFrameEvent{}
			p.mu.RLock()
			for _, h := range p.privatePointerFrames {
				h.HandlePointerFrame(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.privatePointerAxisSources) > 0 {
			ev := PointerAxisSourceEvent{}
			ev.AxisSource = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privatePointerAxisSources {
				h.HandlePointerAxisSource(ev)
			}
			p.mu.RUnlock()
		}
	case 7:
		if len(p.privatePointerAxisStops) > 0 {
			ev := PointerAxisStopEvent{}
			ev.Time = event.Uint32()
			ev.Axis = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privatePointerAxisStops {
				h.HandlePointerAxisStop(ev)
			}
			p.mu.RUnlock()
		}
	case 8:
		if len(p.privatePointerAxisDiscretes) > 0 {
			ev := PointerAxisDiscreteEvent{}
			ev.Axis = event.Uint32()
			ev.Discrete = event.Int32()
			p.mu.RLock()
			for _, h := range p.privatePointerAxisDiscretes {
				h.HandlePointerAxisDiscrete(ev)
			}
			p.mu.RUnlock()
		}
	case 9:
		if len(p.privatePointerAxisValue120s) > 0 {
			ev := PointerAxisValue120Event{}
			ev.Axis = event.Uint32()
			ev.Value120 = event.Int32()
			p.mu.RLock()
			for _, h := range p.privatePointerAxisValue120s {
				h.HandlePointerAxisValue120(ev)
			}
			p.mu.RUnlock()
		}
	case 10:
		if len(p.privatePointerAxisRelativeDirections) > 0 {
			ev := PointerAxisRelativeDirectionEvent{}
			ev.Axis = event.Uint32()
			ev.Direction = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privatePointerAxisRelativeDirections {
				h.HandlePointerAxisRelativeDirection(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// PointerEnterEvent is the enter event
type PointerEnterEvent struct {
	// Serial is the serial number of the enter event
	Serial uint32
	// Surface is the surface entered by the pointer
	Surface *Surface
	// SurfaceX is the surface-local x coordinate
	SurfaceX float32
	// SurfaceY is the surface-local y coordinate
	SurfaceY float32
}

// PointerLeaveEvent is the leave event
type PointerLeaveEvent struct {
	// Serial is the serial number of the leave event
	Serial uint32
	// Surface is the surface left by the pointer
	Surface *Surface
}

// PointerMotionEvent is the pointer motion event
type PointerMotionEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// SurfaceX is the surface-local x coordinate
	SurfaceX float32
	// SurfaceY is the surface-local y coordinate
	SurfaceY float32
	P        *Pointer
}

// PointerButtonEvent is the pointer button event
type PointerButtonEvent struct {
	// Serial is the serial number of the button event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Button is the button that produced the event
	Button uint32
	// State is the physical state of the button
	State uint32
	P     *Pointer
}

// PointerAxisEvent is the axis event
type PointerAxisEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Axis is the axis type
	Axis uint32
	// Value is the length of vector in surface-local coordinate space
	Value float32
}

// PointerFrameEvent is the end of a pointer event sequence
type PointerFrameEvent struct {
}

// PointerAxisSourceEvent is the axis source event
type PointerAxisSourceEvent struct {
	// AxisSource is the source of the axis event
	AxisSource uint32
}

// PointerAxisStopEvent is the axis stop event
type PointerAxisStopEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Axis is the the axis stopped with this event
	Axis uint32
}

// PointerAxisDiscreteEvent is the axis click event
type PointerAxisDiscreteEvent struct {
	// Axis is the axis type
	Axis uint32
	// Discrete is the number of steps
	Discrete int32
}

// PointerAxisValue120Event is the axis high-resolution scroll event
type PointerAxisValue120Event struct {
	// Axis is the axis type
	Axis uint32
	// Value120 is the scroll distance as fraction of 120
	Value120 int32
}

// PointerAxisRelativeDirectionEvent is the axis relative physical direction event
type PointerAxisRelativeDirectionEvent struct {
	// Axis is the axis type
	Axis uint32
	// Direction is the physical direction relative to axis motion
	Direction uint32
}

// PointerEnterHandler is the handler interface for PointerEnterEvent
type PointerEnterHandler interface {
	HandlePointerEnter(PointerEnterEvent)
}

// AddEnterHandler removes the Enter handler
func (p *Pointer) AddEnterHandler(h PointerEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerEnters = append(p.privatePointerEnters, h)
		p.mu.Unlock()
	}
}

// RemoveEnterHandler adds the Enter handler
func (p *Pointer) RemoveEnterHandler(h PointerEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerEnters {
		if e == h {
			p.privatePointerEnters = append(p.privatePointerEnters[:i], p.privatePointerEnters[i+1:]...)
			break
		}
	}
}

// PointerLeaveHandler is the handler interface for PointerLeaveEvent
type PointerLeaveHandler interface {
	HandlePointerLeave(PointerLeaveEvent)
}

// AddLeaveHandler removes the Leave handler
func (p *Pointer) AddLeaveHandler(h PointerLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerLeaves = append(p.privatePointerLeaves, h)
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler adds the Leave handler
func (p *Pointer) RemoveLeaveHandler(h PointerLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerLeaves {
		if e == h {
			p.privatePointerLeaves = append(p.privatePointerLeaves[:i], p.privatePointerLeaves[i+1:]...)
			break
		}
	}
}

// PointerMotionHandler is the handler interface for PointerMotionEvent
type PointerMotionHandler interface {
	HandlePointerMotion(PointerMotionEvent)
}

// AddMotionHandler removes the Motion handler
func (p *Pointer) AddMotionHandler(h PointerMotionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerMotions = append(p.privatePointerMotions, h)
		p.mu.Unlock()
	}
}

// RemoveMotionHandler adds the Motion handler
func (p *Pointer) RemoveMotionHandler(h PointerMotionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerMotions {
		if e == h {
			p.privatePointerMotions = append(p.privatePointerMotions[:i], p.privatePointerMotions[i+1:]...)
			break
		}
	}
}

// PointerButtonHandler is the handler interface for PointerButtonEvent
type PointerButtonHandler interface {
	HandlePointerButton(PointerButtonEvent)
}

// AddButtonHandler removes the Button handler
func (p *Pointer) AddButtonHandler(h PointerButtonHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerButtons = append(p.privatePointerButtons, h)
		p.mu.Unlock()
	}
}

// RemoveButtonHandler adds the Button handler
func (p *Pointer) RemoveButtonHandler(h PointerButtonHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerButtons {
		if e == h {
			p.privatePointerButtons = append(p.privatePointerButtons[:i], p.privatePointerButtons[i+1:]...)
			break
		}
	}
}

// PointerAxisHandler is the handler interface for PointerAxisEvent
type PointerAxisHandler interface {
	HandlePointerAxis(PointerAxisEvent)
}

// AddAxisHandler removes the Axis handler
func (p *Pointer) AddAxisHandler(h PointerAxisHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxiss = append(p.privatePointerAxiss, h)
		p.mu.Unlock()
	}
}

// RemoveAxisHandler adds the Axis handler
func (p *Pointer) RemoveAxisHandler(h PointerAxisHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerAxiss {
		if e == h {
			p.privatePointerAxiss = append(p.privatePointerAxiss[:i], p.privatePointerAxiss[i+1:]...)
			break
		}
	}
}

// PointerFrameHandler is the handler interface for PointerFrameEvent
type PointerFrameHandler interface {
	HandlePointerFrame(PointerFrameEvent)
}

// AddFrameHandler removes the Frame handler
func (p *Pointer) AddFrameHandler(h PointerFrameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerFrames = append(p.privatePointerFrames, h)
		p.mu.Unlock()
	}
}

// RemoveFrameHandler adds the Frame handler
func (p *Pointer) RemoveFrameHandler(h PointerFrameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerFrames {
		if e == h {
			p.privatePointerFrames = append(p.privatePointerFrames[:i], p.privatePointerFrames[i+1:]...)
			break
		}
	}
}

// PointerAxisSourceHandler is the handler interface for PointerAxisSourceEvent
type PointerAxisSourceHandler interface {
	HandlePointerAxisSource(PointerAxisSourceEvent)
}

// AddAxisSourceHandler removes the AxisSource handler
func (p *Pointer) AddAxisSourceHandler(h PointerAxisSourceHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisSources = append(p.privatePointerAxisSources, h)
		p.mu.Unlock()
	}
}

// RemoveAxisSourceHandler adds the AxisSource handler
func (p *Pointer) RemoveAxisSourceHandler(h PointerAxisSourceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerAxisSources {
		if e == h {
			p.privatePointerAxisSources = append(p.privatePointerAxisSources[:i], p.privatePointerAxisSources[i+1:]...)
			break
		}
	}
}

// PointerAxisStopHandler is the handler interface for PointerAxisStopEvent
type PointerAxisStopHandler interface {
	HandlePointerAxisStop(PointerAxisStopEvent)
}

// AddAxisStopHandler removes the AxisStop handler
func (p *Pointer) AddAxisStopHandler(h PointerAxisStopHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisStops = append(p.privatePointerAxisStops, h)
		p.mu.Unlock()
	}
}

// RemoveAxisStopHandler adds the AxisStop handler
func (p *Pointer) RemoveAxisStopHandler(h PointerAxisStopHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerAxisStops {
		if e == h {
			p.privatePointerAxisStops = append(p.privatePointerAxisStops[:i], p.privatePointerAxisStops[i+1:]...)
			break
		}
	}
}

// PointerAxisDiscreteHandler is the handler interface for PointerAxisDiscreteEvent
type PointerAxisDiscreteHandler interface {
	HandlePointerAxisDiscrete(PointerAxisDiscreteEvent)
}

// AddAxisDiscreteHandler removes the AxisDiscrete handler
func (p *Pointer) AddAxisDiscreteHandler(h PointerAxisDiscreteHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisDiscretes = append(p.privatePointerAxisDiscretes, h)
		p.mu.Unlock()
	}
}

// RemoveAxisDiscreteHandler adds the AxisDiscrete handler
func (p *Pointer) RemoveAxisDiscreteHandler(h PointerAxisDiscreteHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerAxisDiscretes {
		if e == h {
			p.privatePointerAxisDiscretes = append(p.privatePointerAxisDiscretes[:i], p.privatePointerAxisDiscretes[i+1:]...)
			break
		}
	}
}

// PointerAxisValue120Handler is the handler interface for PointerAxisValue120Event
type PointerAxisValue120Handler interface {
	HandlePointerAxisValue120(PointerAxisValue120Event)
}

// AddAxisValue120Handler removes the AxisValue120 handler
func (p *Pointer) AddAxisValue120Handler(h PointerAxisValue120Handler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisValue120s = append(p.privatePointerAxisValue120s, h)
		p.mu.Unlock()
	}
}

// RemoveAxisValue120Handler adds the AxisValue120 handler
func (p *Pointer) RemoveAxisValue120Handler(h PointerAxisValue120Handler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerAxisValue120s {
		if e == h {
			p.privatePointerAxisValue120s = append(p.privatePointerAxisValue120s[:i], p.privatePointerAxisValue120s[i+1:]...)
			break
		}
	}
}

// PointerAxisRelativeDirectionHandler is the handler interface for PointerAxisRelativeDirectionEvent
type PointerAxisRelativeDirectionHandler interface {
	HandlePointerAxisRelativeDirection(PointerAxisRelativeDirectionEvent)
}

// AddAxisRelativeDirectionHandler removes the AxisRelativeDirection handler
func (p *Pointer) AddAxisRelativeDirectionHandler(h PointerAxisRelativeDirectionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisRelativeDirections = append(p.privatePointerAxisRelativeDirections, h)
		p.mu.Unlock()
	}
}

// RemoveAxisRelativeDirectionHandler adds the AxisRelativeDirection handler
func (p *Pointer) RemoveAxisRelativeDirectionHandler(h PointerAxisRelativeDirectionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privatePointerAxisRelativeDirections {
		if e == h {
			p.privatePointerAxisRelativeDirections = append(p.privatePointerAxisRelativeDirections[:i], p.privatePointerAxisRelativeDirections[i+1:]...)
			break
		}
	}
}

// Keyboard keyboard input device
type Keyboard struct {
	BaseProxy
	mu                         sync.RWMutex
	privateKeyboardKeymaps     []KeyboardKeymapHandler
	privateKeyboardEnters      []KeyboardEnterHandler
	privateKeyboardLeaves      []KeyboardLeaveHandler
	privateKeyboardKeys        []KeyboardKeyHandler
	privateKeyboardModifierss  []KeyboardModifiersHandler
	privateKeyboardRepeatInfos []KeyboardRepeatInfoHandler
}

// NewKeyboard is a constructor for the Keyboard object
func NewKeyboard(ctx *Context) *Keyboard {
	ret := new(Keyboard)
	ctx.Register(ret)
	return ret
}

// Release release the keyboard object
func (p *Keyboard) Release() error {

	return p.Context().SendRequest(p, 0)
}

// Dispatch dispatches event for object Keyboard
func (p *Keyboard) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateKeyboardKeymaps) > 0 {
			ev := KeyboardKeymapEvent{}
			ev.Format = event.Uint32()
			ev.Fd, ev.FdError = event.FD()
			ev.Size = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateKeyboardKeymaps {
				h.HandleKeyboardKeymap(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateKeyboardEnters) > 0 {
			ev := KeyboardEnterEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			ev.Keys = event.Array()
			p.mu.RLock()
			for _, h := range p.privateKeyboardEnters {
				h.HandleKeyboardEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateKeyboardLeaves) > 0 {
			ev := KeyboardLeaveEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			p.mu.RLock()
			for _, h := range p.privateKeyboardLeaves {
				h.HandleKeyboardLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateKeyboardKeys) > 0 {
			ev := KeyboardKeyEvent{}
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Key = event.Uint32()
			ev.State = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateKeyboardKeys {
				h.HandleKeyboardKey(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateKeyboardModifierss) > 0 {
			ev := KeyboardModifiersEvent{}
			ev.Serial = event.Uint32()
			ev.ModsDepressed = event.Uint32()
			ev.ModsLatched = event.Uint32()
			ev.ModsLocked = event.Uint32()
			ev.Group = event.Uint32()
			p.mu.RLock()
			for _, h := range p.privateKeyboardModifierss {
				h.HandleKeyboardModifiers(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateKeyboardRepeatInfos) > 0 {
			ev := KeyboardRepeatInfoEvent{}
			ev.Rate = event.Int32()
			ev.Delay = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateKeyboardRepeatInfos {
				h.HandleKeyboardRepeatInfo(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// KeyboardKeymapEvent is the keyboard mapping
type KeyboardKeymapEvent struct {
	// Format is the keymap format
	Format uint32
	// Fd is the keymap file descriptor
	Fd uintptr
	// FdError is the keymap file descriptor (error)
	FdError error
	// Size is the keymap size, in bytes
	Size uint32
}

// KeyboardEnterEvent is the enter event
type KeyboardEnterEvent struct {
	// Serial is the serial number of the enter event
	Serial uint32
	// Surface is the surface gaining keyboard focus
	Surface *Surface
	// Keys is the the currently pressed keys
	Keys []int32
}

// KeyboardLeaveEvent is the leave event
type KeyboardLeaveEvent struct {
	// Serial is the serial number of the leave event
	Serial uint32
	// Surface is the surface that lost keyboard focus
	Surface *Surface
}

// KeyboardKeyEvent is the key event
type KeyboardKeyEvent struct {
	// Serial is the serial number of the key event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Key is the key that produced the event
	Key uint32
	// State is the physical state of the key
	State uint32
}

// KeyboardModifiersEvent is the modifier and group state
type KeyboardModifiersEvent struct {
	// Serial is the serial number of the modifiers event
	Serial uint32
	// ModsDepressed is the depressed modifiers
	ModsDepressed uint32
	// ModsLatched is the latched modifiers
	ModsLatched uint32
	// ModsLocked is the locked modifiers
	ModsLocked uint32
	// Group is the keyboard layout
	Group uint32
}

// KeyboardRepeatInfoEvent is the repeat rate and delay
type KeyboardRepeatInfoEvent struct {
	// Rate is the the rate of repeating keys in characters per second
	Rate int32
	// Delay is the delay in milliseconds since key down until repeating starts
	Delay int32
}

// KeyboardKeymapHandler is the handler interface for KeyboardKeymapEvent
type KeyboardKeymapHandler interface {
	HandleKeyboardKeymap(KeyboardKeymapEvent)
}

// AddKeymapHandler removes the Keymap handler
func (p *Keyboard) AddKeymapHandler(h KeyboardKeymapHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardKeymaps = append(p.privateKeyboardKeymaps, h)
		p.mu.Unlock()
	}
}

// RemoveKeymapHandler adds the Keymap handler
func (p *Keyboard) RemoveKeymapHandler(h KeyboardKeymapHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateKeyboardKeymaps {
		if e == h {
			p.privateKeyboardKeymaps = append(p.privateKeyboardKeymaps[:i], p.privateKeyboardKeymaps[i+1:]...)
			break
		}
	}
}

// KeyboardEnterHandler is the handler interface for KeyboardEnterEvent
type KeyboardEnterHandler interface {
	HandleKeyboardEnter(KeyboardEnterEvent)
}

// AddEnterHandler removes the Enter handler
func (p *Keyboard) AddEnterHandler(h KeyboardEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardEnters = append(p.privateKeyboardEnters, h)
		p.mu.Unlock()
	}
}

// RemoveEnterHandler adds the Enter handler
func (p *Keyboard) RemoveEnterHandler(h KeyboardEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateKeyboardEnters {
		if e == h {
			p.privateKeyboardEnters = append(p.privateKeyboardEnters[:i], p.privateKeyboardEnters[i+1:]...)
			break
		}
	}
}

// KeyboardLeaveHandler is the handler interface for KeyboardLeaveEvent
type KeyboardLeaveHandler interface {
	HandleKeyboardLeave(KeyboardLeaveEvent)
}

// AddLeaveHandler removes the Leave handler
func (p *Keyboard) AddLeaveHandler(h KeyboardLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardLeaves = append(p.privateKeyboardLeaves, h)
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler adds the Leave handler
func (p *Keyboard) RemoveLeaveHandler(h KeyboardLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateKeyboardLeaves {
		if e == h {
			p.privateKeyboardLeaves = append(p.privateKeyboardLeaves[:i], p.privateKeyboardLeaves[i+1:]...)
			break
		}
	}
}

// KeyboardKeyHandler is the handler interface for KeyboardKeyEvent
type KeyboardKeyHandler interface {
	HandleKeyboardKey(KeyboardKeyEvent)
}

// AddKeyHandler removes the Key handler
func (p *Keyboard) AddKeyHandler(h KeyboardKeyHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardKeys = append(p.privateKeyboardKeys, h)
		p.mu.Unlock()
	}
}

// RemoveKeyHandler adds the Key handler
func (p *Keyboard) RemoveKeyHandler(h KeyboardKeyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateKeyboardKeys {
		if e == h {
			p.privateKeyboardKeys = append(p.privateKeyboardKeys[:i], p.privateKeyboardKeys[i+1:]...)
			break
		}
	}
}

// KeyboardModifiersHandler is the handler interface for KeyboardModifiersEvent
type KeyboardModifiersHandler interface {
	HandleKeyboardModifiers(KeyboardModifiersEvent)
}

// AddModifiersHandler removes the Modifiers handler
func (p *Keyboard) AddModifiersHandler(h KeyboardModifiersHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardModifierss = append(p.privateKeyboardModifierss, h)
		p.mu.Unlock()
	}
}

// RemoveModifiersHandler adds the Modifiers handler
func (p *Keyboard) RemoveModifiersHandler(h KeyboardModifiersHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateKeyboardModifierss {
		if e == h {
			p.privateKeyboardModifierss = append(p.privateKeyboardModifierss[:i], p.privateKeyboardModifierss[i+1:]...)
			break
		}
	}
}

// KeyboardRepeatInfoHandler is the handler interface for KeyboardRepeatInfoEvent
type KeyboardRepeatInfoHandler interface {
	HandleKeyboardRepeatInfo(KeyboardRepeatInfoEvent)
}

// AddRepeatInfoHandler removes the RepeatInfo handler
func (p *Keyboard) AddRepeatInfoHandler(h KeyboardRepeatInfoHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardRepeatInfos = append(p.privateKeyboardRepeatInfos, h)
		p.mu.Unlock()
	}
}

// RemoveRepeatInfoHandler adds the RepeatInfo handler
func (p *Keyboard) RemoveRepeatInfoHandler(h KeyboardRepeatInfoHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateKeyboardRepeatInfos {
		if e == h {
			p.privateKeyboardRepeatInfos = append(p.privateKeyboardRepeatInfos[:i], p.privateKeyboardRepeatInfos[i+1:]...)
			break
		}
	}
}

// Touch touchscreen input device
type Touch struct {
	BaseProxy
	mu                       sync.RWMutex
	privateTouchDowns        []TouchDownHandler
	privateTouchUps          []TouchUpHandler
	privateTouchMotions      []TouchMotionHandler
	privateTouchFrames       []TouchFrameHandler
	privateTouchCancels      []TouchCancelHandler
	privateTouchShapes       []TouchShapeHandler
	privateTouchOrientations []TouchOrientationHandler
}

// NewTouch is a constructor for the Touch object
func NewTouch(ctx *Context) *Touch {
	ret := new(Touch)
	ctx.Register(ret)
	return ret
}

// Release release the touch object
func (p *Touch) Release() error {

	return p.Context().SendRequest(p, 0)
}

// Dispatch dispatches event for object Touch
func (p *Touch) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateTouchDowns) > 0 {
			ev := TouchDownEvent{}
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			ev.Id = event.Int32()
			ev.X = event.Float32()
			ev.Y = event.Float32()
			p.mu.RLock()
			for _, h := range p.privateTouchDowns {
				h.HandleTouchDown(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateTouchUps) > 0 {
			ev := TouchUpEvent{}
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Id = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateTouchUps {
				h.HandleTouchUp(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateTouchMotions) > 0 {
			ev := TouchMotionEvent{}
			ev.Time = event.Uint32()
			ev.Id = event.Int32()
			ev.X = event.Float32()
			ev.Y = event.Float32()
			p.mu.RLock()
			for _, h := range p.privateTouchMotions {
				h.HandleTouchMotion(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateTouchFrames) > 0 {
			ev := TouchFrameEvent{}
			p.mu.RLock()
			for _, h := range p.privateTouchFrames {
				h.HandleTouchFrame(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateTouchCancels) > 0 {
			ev := TouchCancelEvent{}
			p.mu.RLock()
			for _, h := range p.privateTouchCancels {
				h.HandleTouchCancel(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateTouchShapes) > 0 {
			ev := TouchShapeEvent{}
			ev.Id = event.Int32()
			ev.Major = event.Float32()
			ev.Minor = event.Float32()
			p.mu.RLock()
			for _, h := range p.privateTouchShapes {
				h.HandleTouchShape(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.privateTouchOrientations) > 0 {
			ev := TouchOrientationEvent{}
			ev.Id = event.Int32()
			ev.Orientation = event.Float32()
			p.mu.RLock()
			for _, h := range p.privateTouchOrientations {
				h.HandleTouchOrientation(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// TouchDownEvent is the touch down event and beginning of a touch sequence
type TouchDownEvent struct {
	// Serial is the serial number of the touch down event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Surface is the surface touched
	Surface *Surface
	// Id is the the unique ID of this touch point
	Id int32
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32
}

// TouchUpEvent is the end of a touch event sequence
type TouchUpEvent struct {
	// Serial is the serial number of the touch up event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Id is the the unique ID of this touch point
	Id int32
}

// TouchMotionEvent is the update of touch point coordinates
type TouchMotionEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Id is the the unique ID of this touch point
	Id int32
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32
}

// TouchFrameEvent is the end of touch frame event
type TouchFrameEvent struct {
}

// TouchCancelEvent is the touch session cancelled
type TouchCancelEvent struct {
}

// TouchShapeEvent is the update shape of touch point
type TouchShapeEvent struct {
	// Id is the the unique ID of this touch point
	Id int32
	// Major is the length of the major axis in surface-local coordinates
	Major float32
	// Minor is the length of the minor axis in surface-local coordinates
	Minor float32
}

// TouchOrientationEvent is the update orientation of touch point
type TouchOrientationEvent struct {
	// Id is the the unique ID of this touch point
	Id int32
	// Orientation is the angle between major axis and positive surface y-axis in degrees
	Orientation float32
}

// TouchDownHandler is the handler interface for TouchDownEvent
type TouchDownHandler interface {
	HandleTouchDown(TouchDownEvent)
}

// AddDownHandler removes the Down handler
func (p *Touch) AddDownHandler(h TouchDownHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchDowns = append(p.privateTouchDowns, h)
		p.mu.Unlock()
	}
}

// RemoveDownHandler adds the Down handler
func (p *Touch) RemoveDownHandler(h TouchDownHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateTouchDowns {
		if e == h {
			p.privateTouchDowns = append(p.privateTouchDowns[:i], p.privateTouchDowns[i+1:]...)
			break
		}
	}
}

// TouchUpHandler is the handler interface for TouchUpEvent
type TouchUpHandler interface {
	HandleTouchUp(TouchUpEvent)
}

// AddUpHandler removes the Up handler
func (p *Touch) AddUpHandler(h TouchUpHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchUps = append(p.privateTouchUps, h)
		p.mu.Unlock()
	}
}

// RemoveUpHandler adds the Up handler
func (p *Touch) RemoveUpHandler(h TouchUpHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateTouchUps {
		if e == h {
			p.privateTouchUps = append(p.privateTouchUps[:i], p.privateTouchUps[i+1:]...)
			break
		}
	}
}

// TouchMotionHandler is the handler interface for TouchMotionEvent
type TouchMotionHandler interface {
	HandleTouchMotion(TouchMotionEvent)
}

// AddMotionHandler removes the Motion handler
func (p *Touch) AddMotionHandler(h TouchMotionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchMotions = append(p.privateTouchMotions, h)
		p.mu.Unlock()
	}
}

// RemoveMotionHandler adds the Motion handler
func (p *Touch) RemoveMotionHandler(h TouchMotionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateTouchMotions {
		if e == h {
			p.privateTouchMotions = append(p.privateTouchMotions[:i], p.privateTouchMotions[i+1:]...)
			break
		}
	}
}

// TouchFrameHandler is the handler interface for TouchFrameEvent
type TouchFrameHandler interface {
	HandleTouchFrame(TouchFrameEvent)
}

// AddFrameHandler removes the Frame handler
func (p *Touch) AddFrameHandler(h TouchFrameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchFrames = append(p.privateTouchFrames, h)
		p.mu.Unlock()
	}
}

// RemoveFrameHandler adds the Frame handler
func (p *Touch) RemoveFrameHandler(h TouchFrameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateTouchFrames {
		if e == h {
			p.privateTouchFrames = append(p.privateTouchFrames[:i], p.privateTouchFrames[i+1:]...)
			break
		}
	}
}

// TouchCancelHandler is the handler interface for TouchCancelEvent
type TouchCancelHandler interface {
	HandleTouchCancel(TouchCancelEvent)
}

// AddCancelHandler removes the Cancel handler
func (p *Touch) AddCancelHandler(h TouchCancelHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchCancels = append(p.privateTouchCancels, h)
		p.mu.Unlock()
	}
}

// RemoveCancelHandler adds the Cancel handler
func (p *Touch) RemoveCancelHandler(h TouchCancelHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateTouchCancels {
		if e == h {
			p.privateTouchCancels = append(p.privateTouchCancels[:i], p.privateTouchCancels[i+1:]...)
			break
		}
	}
}

// TouchShapeHandler is the handler interface for TouchShapeEvent
type TouchShapeHandler interface {
	HandleTouchShape(TouchShapeEvent)
}

// AddShapeHandler removes the Shape handler
func (p *Touch) AddShapeHandler(h TouchShapeHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchShapes = append(p.privateTouchShapes, h)
		p.mu.Unlock()
	}
}

// RemoveShapeHandler adds the Shape handler
func (p *Touch) RemoveShapeHandler(h TouchShapeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateTouchShapes {
		if e == h {
			p.privateTouchShapes = append(p.privateTouchShapes[:i], p.privateTouchShapes[i+1:]...)
			break
		}
	}
}

// TouchOrientationHandler is the handler interface for TouchOrientationEvent
type TouchOrientationHandler interface {
	HandleTouchOrientation(TouchOrientationEvent)
}

// AddOrientationHandler removes the Orientation handler
func (p *Touch) AddOrientationHandler(h TouchOrientationHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchOrientations = append(p.privateTouchOrientations, h)
		p.mu.Unlock()
	}
}

// RemoveOrientationHandler adds the Orientation handler
func (p *Touch) RemoveOrientationHandler(h TouchOrientationHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateTouchOrientations {
		if e == h {
			p.privateTouchOrientations = append(p.privateTouchOrientations[:i], p.privateTouchOrientations[i+1:]...)
			break
		}
	}
}

// Output compositor output region
type Output struct {
	BaseProxy
	mu                        sync.RWMutex
	privateOutputGeometrys    []OutputGeometryHandler
	privateOutputModes        []OutputModeHandler
	privateOutputDones        []OutputDoneHandler
	privateOutputScales       []OutputScaleHandler
	privateOutputNames        []OutputNameHandler
	privateOutputDescriptions []OutputDescriptionHandler
}

// NewOutput is a constructor for the Output object
func NewOutput(ctx *Context) *Output {
	ret := new(Output)
	ctx.Register(ret)
	return ret
}

// Release release the output object
func (p *Output) Release() error {

	return p.Context().SendRequest(p, 0)
}

// Dispatch dispatches event for object Output
func (p *Output) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateOutputGeometrys) > 0 {
			ev := OutputGeometryEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.PhysicalWidth = event.Int32()
			ev.PhysicalHeight = event.Int32()
			ev.Subpixel = event.Int32()
			ev.Make = event.String()
			ev.Model = event.String()
			ev.Transform = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateOutputGeometrys {
				h.HandleOutputGeometry(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateOutputModes) > 0 {
			ev := OutputModeEvent{}
			ev.Flags = event.Uint32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			ev.Refresh = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateOutputModes {
				h.HandleOutputMode(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateOutputDones) > 0 {
			ev := OutputDoneEvent{}
			p.mu.RLock()
			for _, h := range p.privateOutputDones {
				h.HandleOutputDone(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateOutputScales) > 0 {
			ev := OutputScaleEvent{}
			ev.Factor = event.Int32()
			p.mu.RLock()
			for _, h := range p.privateOutputScales {
				h.HandleOutputScale(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateOutputNames) > 0 {
			ev := OutputNameEvent{}
			ev.Name = event.String()
			p.mu.RLock()
			for _, h := range p.privateOutputNames {
				h.HandleOutputName(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateOutputDescriptions) > 0 {
			ev := OutputDescriptionEvent{}
			ev.Description = event.String()
			p.mu.RLock()
			for _, h := range p.privateOutputDescriptions {
				h.HandleOutputDescription(ev)
			}
			p.mu.RUnlock()
		}

	}
}

// OutputGeometryEvent is the properties of the output
type OutputGeometryEvent struct {
	// X is the x position within the global compositor space
	X int32
	// Y is the y position within the global compositor space
	Y int32
	// PhysicalWidth is the width in millimeters of the output
	PhysicalWidth int32
	// PhysicalHeight is the height in millimeters of the output
	PhysicalHeight int32
	// Subpixel is the subpixel orientation of the output
	Subpixel int32
	// Make is the textual description of the manufacturer
	Make string
	// Model is the textual description of the model
	Model string
	// Transform is the transform that maps framebuffer to output
	Transform int32
}

// OutputModeEvent is the advertise available modes for the output
type OutputModeEvent struct {
	// Flags is the bitfield of mode flags
	Flags uint32
	// Width is the width of the mode in hardware units
	Width int32
	// Height is the height of the mode in hardware units
	Height int32
	// Refresh is the vertical refresh rate in mHz
	Refresh int32
}

// OutputDoneEvent is the sent all information about output
type OutputDoneEvent struct {
}

// OutputScaleEvent is the output scaling properties
type OutputScaleEvent struct {
	// Factor is the scaling factor of output
	Factor int32
}

// OutputNameEvent is the name of this output
type OutputNameEvent struct {
	// Name is the output name
	Name string
}

// OutputDescriptionEvent is the human-readable description of this output
type OutputDescriptionEvent struct {
	// Description is the output description
	Description string
}

// OutputGeometryHandler is the handler interface for OutputGeometryEvent
type OutputGeometryHandler interface {
	HandleOutputGeometry(OutputGeometryEvent)
}

// AddGeometryHandler removes the Geometry handler
func (p *Output) AddGeometryHandler(h OutputGeometryHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputGeometrys = append(p.privateOutputGeometrys, h)
		p.mu.Unlock()
	}
}

// RemoveGeometryHandler adds the Geometry handler
func (p *Output) RemoveGeometryHandler(h OutputGeometryHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateOutputGeometrys {
		if e == h {
			p.privateOutputGeometrys = append(p.privateOutputGeometrys[:i], p.privateOutputGeometrys[i+1:]...)
			break
		}
	}
}

// OutputModeHandler is the handler interface for OutputModeEvent
type OutputModeHandler interface {
	HandleOutputMode(OutputModeEvent)
}

// AddModeHandler removes the Mode handler
func (p *Output) AddModeHandler(h OutputModeHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputModes = append(p.privateOutputModes, h)
		p.mu.Unlock()
	}
}

// RemoveModeHandler adds the Mode handler
func (p *Output) RemoveModeHandler(h OutputModeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateOutputModes {
		if e == h {
			p.privateOutputModes = append(p.privateOutputModes[:i], p.privateOutputModes[i+1:]...)
			break
		}
	}
}

// OutputDoneHandler is the handler interface for OutputDoneEvent
type OutputDoneHandler interface {
	HandleOutputDone(OutputDoneEvent)
}

// AddDoneHandler removes the Done handler
func (p *Output) AddDoneHandler(h OutputDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputDones = append(p.privateOutputDones, h)
		p.mu.Unlock()
	}
}

// RemoveDoneHandler adds the Done handler
func (p *Output) RemoveDoneHandler(h OutputDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateOutputDones {
		if e == h {
			p.privateOutputDones = append(p.privateOutputDones[:i], p.privateOutputDones[i+1:]...)
			break
		}
	}
}

// OutputScaleHandler is the handler interface for OutputScaleEvent
type OutputScaleHandler interface {
	HandleOutputScale(OutputScaleEvent)
}

// AddScaleHandler removes the Scale handler
func (p *Output) AddScaleHandler(h OutputScaleHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputScales = append(p.privateOutputScales, h)
		p.mu.Unlock()
	}
}

// RemoveScaleHandler adds the Scale handler
func (p *Output) RemoveScaleHandler(h OutputScaleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateOutputScales {
		if e == h {
			p.privateOutputScales = append(p.privateOutputScales[:i], p.privateOutputScales[i+1:]...)
			break
		}
	}
}

// OutputNameHandler is the handler interface for OutputNameEvent
type OutputNameHandler interface {
	HandleOutputName(OutputNameEvent)
}

// AddNameHandler removes the Name handler
func (p *Output) AddNameHandler(h OutputNameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputNames = append(p.privateOutputNames, h)
		p.mu.Unlock()
	}
}

// RemoveNameHandler adds the Name handler
func (p *Output) RemoveNameHandler(h OutputNameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateOutputNames {
		if e == h {
			p.privateOutputNames = append(p.privateOutputNames[:i], p.privateOutputNames[i+1:]...)
			break
		}
	}
}

// OutputDescriptionHandler is the handler interface for OutputDescriptionEvent
type OutputDescriptionHandler interface {
	HandleOutputDescription(OutputDescriptionEvent)
}

// AddDescriptionHandler removes the Description handler
func (p *Output) AddDescriptionHandler(h OutputDescriptionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputDescriptions = append(p.privateOutputDescriptions, h)
		p.mu.Unlock()
	}
}

// RemoveDescriptionHandler adds the Description handler
func (p *Output) RemoveDescriptionHandler(h OutputDescriptionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.privateOutputDescriptions {
		if e == h {
			p.privateOutputDescriptions = append(p.privateOutputDescriptions[:i], p.privateOutputDescriptions[i+1:]...)
			break
		}
	}
}

// Region region interface
type Region struct {
	BaseProxy
}

// NewRegion is a constructor for the Region object
func NewRegion(ctx *Context) *Region {
	ret := new(Region)
	ctx.Register(ret)
	return ret
}

// Destroy destroy region
func (p *Region) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// Add add rectangle to region
func (p *Region) Add(X int32, Y int32, Width int32, Height int32) error {

	return p.Context().SendRequest(p, 1, X, Y, Width, Height)
}

// Subtract subtract rectangle from region
func (p *Region) Subtract(X int32, Y int32, Width int32, Height int32) error {

	return p.Context().SendRequest(p, 2, X, Y, Width, Height)
}

// Dispatch dispatches event for object Region
func (p *Region) Dispatch(event *Event) {
	switch event.Opcode {

	}
}

// Subcompositor sub-surface compositing
type Subcompositor struct {
	BaseProxy
}

// NewSubcompositor is a constructor for the Subcompositor object
func NewSubcompositor(ctx *Context) *Subcompositor {
	ret := new(Subcompositor)
	ctx.Register(ret)
	return ret
}

// Destroy unbind from the subcompositor interface
func (p *Subcompositor) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// GetSubsurface give a surface the role sub-surface
func (p *Subcompositor) GetSubsurface(Surface *Surface, Parent *Surface) (*Subsurface, error) {
	retId := NewSubsurface(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId, Surface, Parent)
}

// Dispatch dispatches event for object Subcompositor
func (p *Subcompositor) Dispatch(event *Event) {
	switch event.Opcode {

	}
}

// Subsurface sub-surface interface to a wl_surface
type Subsurface struct {
	BaseProxy
}

// NewSubsurface is a constructor for the Subsurface object
func NewSubsurface(ctx *Context) *Subsurface {
	ret := new(Subsurface)
	ctx.Register(ret)
	return ret
}

// Destroy remove sub-surface interface
func (p *Subsurface) Destroy() error {

	return p.Context().SendRequest(p, 0)
}

// SetPosition reposition the sub-surface
func (p *Subsurface) SetPosition(X int32, Y int32) error {

	return p.Context().SendRequest(p, 1, X, Y)
}

// PlaceAbove restack the sub-surface
func (p *Subsurface) PlaceAbove(Sibling *Surface) error {

	return p.Context().SendRequest(p, 2, Sibling)
}

// PlaceBelow restack the sub-surface
func (p *Subsurface) PlaceBelow(Sibling *Surface) error {

	return p.Context().SendRequest(p, 3, Sibling)
}

// SetSync set sub-surface to synchronized mode
func (p *Subsurface) SetSync() error {

	return p.Context().SendRequest(p, 4)
}

// SetDesync set sub-surface to desynchronized mode
func (p *Subsurface) SetDesync() error {

	return p.Context().SendRequest(p, 5)
}

// Dispatch dispatches event for object Subsurface
func (p *Subsurface) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
