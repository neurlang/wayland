// This file is autogenerated from: wl/wayland.xml
// Do not edit

// Package wl implements the wayland protocol
package wl

import (
	"sync"

)
// DisplayErrorInvalidObject means server couldn't find object
const DisplayErrorInvalidObject = 0

// DisplayErrorInvalidMethod means method doesn't exist on the specified interface or malformed request
const DisplayErrorInvalidMethod = 1

// DisplayErrorNoMemory means server is out of memory
const DisplayErrorNoMemory = 2

// DisplayErrorImplementation means implementation error in compositor
const DisplayErrorImplementation = 3

// ShmErrorInvalidFormat means buffer format is not known
const ShmErrorInvalidFormat = 0

// ShmErrorInvalidStride means invalid size or stride during pool or buffer creation
const ShmErrorInvalidStride = 1

// ShmErrorInvalidFd means mmapping the file descriptor failed
const ShmErrorInvalidFd = 2

// ShmFormatArgb8888 means 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
const ShmFormatArgb8888 = 0

// ShmFormatXrgb8888 means 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
const ShmFormatXrgb8888 = 1

// ShmFormatC8 means 8-bit color index format, [7:0] C
const ShmFormatC8 = 0x20203843

// ShmFormatRgb332 means 8-bit RGB format, [7:0] R:G:B 3:3:2
const ShmFormatRgb332 = 0x38424752

// ShmFormatBgr233 means 8-bit BGR format, [7:0] B:G:R 2:3:3
const ShmFormatBgr233 = 0x38524742

// ShmFormatXrgb4444 means 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
const ShmFormatXrgb4444 = 0x32315258

// ShmFormatXbgr4444 means 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
const ShmFormatXbgr4444 = 0x32314258

// ShmFormatRgbx4444 means 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
const ShmFormatRgbx4444 = 0x32315852

// ShmFormatBgrx4444 means 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
const ShmFormatBgrx4444 = 0x32315842

// ShmFormatArgb4444 means 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
const ShmFormatArgb4444 = 0x32315241

// ShmFormatAbgr4444 means 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
const ShmFormatAbgr4444 = 0x32314241

// ShmFormatRgba4444 means 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
const ShmFormatRgba4444 = 0x32314152

// ShmFormatBgra4444 means 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
const ShmFormatBgra4444 = 0x32314142

// ShmFormatXrgb1555 means 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
const ShmFormatXrgb1555 = 0x35315258

// ShmFormatXbgr1555 means 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
const ShmFormatXbgr1555 = 0x35314258

// ShmFormatRgbx5551 means 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
const ShmFormatRgbx5551 = 0x35315852

// ShmFormatBgrx5551 means 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
const ShmFormatBgrx5551 = 0x35315842

// ShmFormatArgb1555 means 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
const ShmFormatArgb1555 = 0x35315241

// ShmFormatAbgr1555 means 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
const ShmFormatAbgr1555 = 0x35314241

// ShmFormatRgba5551 means 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
const ShmFormatRgba5551 = 0x35314152

// ShmFormatBgra5551 means 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
const ShmFormatBgra5551 = 0x35314142

// ShmFormatRgb565 means 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
const ShmFormatRgb565 = 0x36314752

// ShmFormatBgr565 means 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
const ShmFormatBgr565 = 0x36314742

// ShmFormatRgb888 means 24-bit RGB format, [23:0] R:G:B little endian
const ShmFormatRgb888 = 0x34324752

// ShmFormatBgr888 means 24-bit BGR format, [23:0] B:G:R little endian
const ShmFormatBgr888 = 0x34324742

// ShmFormatXbgr8888 means 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
const ShmFormatXbgr8888 = 0x34324258

// ShmFormatRgbx8888 means 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
const ShmFormatRgbx8888 = 0x34325852

// ShmFormatBgrx8888 means 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
const ShmFormatBgrx8888 = 0x34325842

// ShmFormatAbgr8888 means 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
const ShmFormatAbgr8888 = 0x34324241

// ShmFormatRgba8888 means 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
const ShmFormatRgba8888 = 0x34324152

// ShmFormatBgra8888 means 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
const ShmFormatBgra8888 = 0x34324142

// ShmFormatXrgb2101010 means 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
const ShmFormatXrgb2101010 = 0x30335258

// ShmFormatXbgr2101010 means 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
const ShmFormatXbgr2101010 = 0x30334258

// ShmFormatRgbx1010102 means 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
const ShmFormatRgbx1010102 = 0x30335852

// ShmFormatBgrx1010102 means 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
const ShmFormatBgrx1010102 = 0x30335842

// ShmFormatArgb2101010 means 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
const ShmFormatArgb2101010 = 0x30335241

// ShmFormatAbgr2101010 means 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
const ShmFormatAbgr2101010 = 0x30334241

// ShmFormatRgba1010102 means 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
const ShmFormatRgba1010102 = 0x30334152

// ShmFormatBgra1010102 means 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
const ShmFormatBgra1010102 = 0x30334142

// ShmFormatYuyv means packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
const ShmFormatYuyv = 0x56595559

// ShmFormatYvyu means packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
const ShmFormatYvyu = 0x55595659

// ShmFormatUyvy means packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
const ShmFormatUyvy = 0x59565955

// ShmFormatVyuy means packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
const ShmFormatVyuy = 0x59555956

// ShmFormatAyuv means packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
const ShmFormatAyuv = 0x56555941

// ShmFormatNv12 means 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
const ShmFormatNv12 = 0x3231564e

// ShmFormatNv21 means 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
const ShmFormatNv21 = 0x3132564e

// ShmFormatNv16 means 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
const ShmFormatNv16 = 0x3631564e

// ShmFormatNv61 means 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
const ShmFormatNv61 = 0x3136564e

// ShmFormatYuv410 means 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv410 = 0x39565559

// ShmFormatYvu410 means 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu410 = 0x39555659

// ShmFormatYuv411 means 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv411 = 0x31315559

// ShmFormatYvu411 means 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu411 = 0x31315659

// ShmFormatYuv420 means 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv420 = 0x32315559

// ShmFormatYvu420 means 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu420 = 0x32315659

// ShmFormatYuv422 means 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv422 = 0x36315559

// ShmFormatYvu422 means 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu422 = 0x36315659

// ShmFormatYuv444 means 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
const ShmFormatYuv444 = 0x34325559

// ShmFormatYvu444 means 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
const ShmFormatYvu444 = 0x34325659

// ShmFormatR8 means [7:0] R
const ShmFormatR8 = 0x20203852

// ShmFormatR16 means [15:0] R little endian
const ShmFormatR16 = 0x20363152

// ShmFormatRg88 means [15:0] R:G 8:8 little endian
const ShmFormatRg88 = 0x38384752

// ShmFormatGr88 means [15:0] G:R 8:8 little endian
const ShmFormatGr88 = 0x38385247

// ShmFormatRg1616 means [31:0] R:G 16:16 little endian
const ShmFormatRg1616 = 0x32334752

// ShmFormatGr1616 means [31:0] G:R 16:16 little endian
const ShmFormatGr1616 = 0x32335247

// ShmFormatXrgb16161616f means [63:0] x:R:G:B 16:16:16:16 little endian
const ShmFormatXrgb16161616f = 0x48345258

// ShmFormatXbgr16161616f means [63:0] x:B:G:R 16:16:16:16 little endian
const ShmFormatXbgr16161616f = 0x48344258

// ShmFormatArgb16161616f means [63:0] A:R:G:B 16:16:16:16 little endian
const ShmFormatArgb16161616f = 0x48345241

// ShmFormatAbgr16161616f means [63:0] A:B:G:R 16:16:16:16 little endian
const ShmFormatAbgr16161616f = 0x48344241

// ShmFormatXyuv8888 means [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
const ShmFormatXyuv8888 = 0x56555958

// ShmFormatVuy888 means [23:0] Cr:Cb:Y 8:8:8 little endian
const ShmFormatVuy888 = 0x34325556

// ShmFormatVuy101010 means Y followed by U then V, 10:10:10. Non-linear modifier only
const ShmFormatVuy101010 = 0x30335556

// ShmFormatY210 means [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
const ShmFormatY210 = 0x30313259

// ShmFormatY212 means [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
const ShmFormatY212 = 0x32313259

// ShmFormatY216 means [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
const ShmFormatY216 = 0x36313259

// ShmFormatY410 means [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
const ShmFormatY410 = 0x30313459

// ShmFormatY412 means [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
const ShmFormatY412 = 0x32313459

// ShmFormatY416 means [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
const ShmFormatY416 = 0x36313459

// ShmFormatXvyu2101010 means [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
const ShmFormatXvyu2101010 = 0x30335658

// ShmFormatXvyu1216161616 means [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
const ShmFormatXvyu1216161616 = 0x36335658

// ShmFormatXvyu16161616 means [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
const ShmFormatXvyu16161616 = 0x38345658

// ShmFormatY0l0 means [63:0] A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
const ShmFormatY0l0 = 0x304c3059

// ShmFormatX0l0 means [63:0] X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
const ShmFormatX0l0 = 0x304c3058

// ShmFormatY0l2 means [63:0] A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
const ShmFormatY0l2 = 0x324c3059

// ShmFormatX0l2 means [63:0] X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
const ShmFormatX0l2 = 0x324c3058

// ShmFormatYuv4208bit
const ShmFormatYuv4208bit = 0x38305559

// ShmFormatYuv42010bit
const ShmFormatYuv42010bit = 0x30315559

// ShmFormatXrgb8888A8
const ShmFormatXrgb8888A8 = 0x38415258

// ShmFormatXbgr8888A8
const ShmFormatXbgr8888A8 = 0x38414258

// ShmFormatRgbx8888A8
const ShmFormatRgbx8888A8 = 0x38415852

// ShmFormatBgrx8888A8
const ShmFormatBgrx8888A8 = 0x38415842

// ShmFormatRgb888A8
const ShmFormatRgb888A8 = 0x38413852

// ShmFormatBgr888A8
const ShmFormatBgr888A8 = 0x38413842

// ShmFormatRgb565A8
const ShmFormatRgb565A8 = 0x38413552

// ShmFormatBgr565A8
const ShmFormatBgr565A8 = 0x38413542

// ShmFormatNv24 means non-subsampled Cr:Cb plane
const ShmFormatNv24 = 0x3432564e

// ShmFormatNv42 means non-subsampled Cb:Cr plane
const ShmFormatNv42 = 0x3234564e

// ShmFormatP210 means 2x1 subsampled Cr:Cb plane, 10 bit per channel
const ShmFormatP210 = 0x30313250

// ShmFormatP010 means 2x2 subsampled Cr:Cb plane 10 bits per channel
const ShmFormatP010 = 0x30313050

// ShmFormatP012 means 2x2 subsampled Cr:Cb plane 12 bits per channel
const ShmFormatP012 = 0x32313050

// ShmFormatP016 means 2x2 subsampled Cr:Cb plane 16 bits per channel
const ShmFormatP016 = 0x36313050

// ShmFormatAxbxgxrx106106106106 means [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
const ShmFormatAxbxgxrx106106106106 = 0x30314241

// ShmFormatNv15 means 2x2 subsampled Cr:Cb plane
const ShmFormatNv15 = 0x3531564e

// ShmFormatQ410
const ShmFormatQ410 = 0x30313451

// ShmFormatQ401
const ShmFormatQ401 = 0x31303451

// ShmFormatXrgb16161616 means [63:0] x:R:G:B 16:16:16:16 little endian
const ShmFormatXrgb16161616 = 0x38345258

// ShmFormatXbgr16161616 means [63:0] x:B:G:R 16:16:16:16 little endian
const ShmFormatXbgr16161616 = 0x38344258

// ShmFormatArgb16161616 means [63:0] A:R:G:B 16:16:16:16 little endian
const ShmFormatArgb16161616 = 0x38345241

// ShmFormatAbgr16161616 means [63:0] A:B:G:R 16:16:16:16 little endian
const ShmFormatAbgr16161616 = 0x38344241

// ShmFormatC1 means [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
const ShmFormatC1 = 0x20203143

// ShmFormatC2 means [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
const ShmFormatC2 = 0x20203243

// ShmFormatC4 means [7:0] C0:C1 4:4 two pixels/byte
const ShmFormatC4 = 0x20203443

// ShmFormatD1 means [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
const ShmFormatD1 = 0x20203144

// ShmFormatD2 means [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
const ShmFormatD2 = 0x20203244

// ShmFormatD4 means [7:0] D0:D1 4:4 two pixels/byte
const ShmFormatD4 = 0x20203444

// ShmFormatD8 means [7:0] D
const ShmFormatD8 = 0x20203844

// ShmFormatR1 means [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
const ShmFormatR1 = 0x20203152

// ShmFormatR2 means [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
const ShmFormatR2 = 0x20203252

// ShmFormatR4 means [7:0] R0:R1 4:4 two pixels/byte
const ShmFormatR4 = 0x20203452

// ShmFormatR10 means [15:0] x:R 6:10 little endian
const ShmFormatR10 = 0x20303152

// ShmFormatR12 means [15:0] x:R 4:12 little endian
const ShmFormatR12 = 0x20323152

// ShmFormatAvuy8888 means [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
const ShmFormatAvuy8888 = 0x59555641

// ShmFormatXvuy8888 means [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
const ShmFormatXvuy8888 = 0x59555658

// ShmFormatP030 means 2x2 subsampled Cr:Cb plane 10 bits per channel packed
const ShmFormatP030 = 0x30333050

// DataOfferErrorInvalidFinish means finish request was called untimely
const DataOfferErrorInvalidFinish = 0

// DataOfferErrorInvalidActionMask means action mask contains invalid values
const DataOfferErrorInvalidActionMask = 1

// DataOfferErrorInvalidAction means action argument has an invalid value
const DataOfferErrorInvalidAction = 2

// DataOfferErrorInvalidOffer means offer doesn't accept this request
const DataOfferErrorInvalidOffer = 3

// DataSourceErrorInvalidActionMask means action mask contains invalid values
const DataSourceErrorInvalidActionMask = 0

// DataSourceErrorInvalidSource means source doesn't accept this request
const DataSourceErrorInvalidSource = 1

// DataDeviceErrorRole means given wl_surface has another role
const DataDeviceErrorRole = 0

// DataDeviceErrorUsedSource means source has already been used
const DataDeviceErrorUsedSource = 1

// DataDeviceManagerDndActionNone means no action
const DataDeviceManagerDndActionNone = 0

// DataDeviceManagerDndActionCopy means copy action
const DataDeviceManagerDndActionCopy = 1

// DataDeviceManagerDndActionMove means move action
const DataDeviceManagerDndActionMove = 2

// DataDeviceManagerDndActionAsk means ask action
const DataDeviceManagerDndActionAsk = 4

// ShellErrorRole means given wl_surface has another role
const ShellErrorRole = 0

// ShellSurfaceResizeNone means no edge
const ShellSurfaceResizeNone = 0

// ShellSurfaceResizeTop means top edge
const ShellSurfaceResizeTop = 1

// ShellSurfaceResizeBottom means bottom edge
const ShellSurfaceResizeBottom = 2

// ShellSurfaceResizeLeft means left edge
const ShellSurfaceResizeLeft = 4

// ShellSurfaceResizeTopLeft means top and left edges
const ShellSurfaceResizeTopLeft = 5

// ShellSurfaceResizeBottomLeft means bottom and left edges
const ShellSurfaceResizeBottomLeft = 6

// ShellSurfaceResizeRight means right edge
const ShellSurfaceResizeRight = 8

// ShellSurfaceResizeTopRight means top and right edges
const ShellSurfaceResizeTopRight = 9

// ShellSurfaceResizeBottomRight means bottom and right edges
const ShellSurfaceResizeBottomRight = 10

// ShellSurfaceTransientInactive means do not set keyboard focus
const ShellSurfaceTransientInactive = 0x1

// ShellSurfaceFullscreenMethodDefault means no preference, apply default policy
const ShellSurfaceFullscreenMethodDefault = 0

// ShellSurfaceFullscreenMethodScale means scale, preserve the surface's aspect ratio and center on output
const ShellSurfaceFullscreenMethodScale = 1

// ShellSurfaceFullscreenMethodDriver means switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
const ShellSurfaceFullscreenMethodDriver = 2

// ShellSurfaceFullscreenMethodFill means no upscaling, center on output and add black borders to compensate size mismatch
const ShellSurfaceFullscreenMethodFill = 3

// SurfaceErrorInvalidScale means buffer scale value is invalid
const SurfaceErrorInvalidScale = 0

// SurfaceErrorInvalidTransform means buffer transform value is invalid
const SurfaceErrorInvalidTransform = 1

// SurfaceErrorInvalidSize means buffer size is invalid
const SurfaceErrorInvalidSize = 2

// SurfaceErrorInvalidOffset means buffer offset is invalid
const SurfaceErrorInvalidOffset = 3

// SurfaceErrorDefunctRoleObject means surface was destroyed before its role object
const SurfaceErrorDefunctRoleObject = 4

// SeatCapabilityPointer means the seat has pointer devices
const SeatCapabilityPointer = 1

// SeatCapabilityKeyboard means the seat has one or more keyboards
const SeatCapabilityKeyboard = 2

// SeatCapabilityTouch means the seat has touch devices
const SeatCapabilityTouch = 4

// SeatErrorMissingCapability means get_pointer, get_keyboard or get_touch called on seat without the matching capability
const SeatErrorMissingCapability = 0

// PointerErrorRole means given wl_surface has another role
const PointerErrorRole = 0

// PointerButtonStateReleased means the button is not pressed
const PointerButtonStateReleased = 0

// PointerButtonStatePressed means the button is pressed
const PointerButtonStatePressed = 1

// PointerAxisVerticalScroll means vertical axis
const PointerAxisVerticalScroll = 0

// PointerAxisHorizontalScroll means horizontal axis
const PointerAxisHorizontalScroll = 1

// PointerAxisSourceWheel means a physical wheel rotation
const PointerAxisSourceWheel = 0

// PointerAxisSourceFinger means finger on a touch surface
const PointerAxisSourceFinger = 1

// PointerAxisSourceContinuous means continuous coordinate space
const PointerAxisSourceContinuous = 2

// PointerAxisSourceWheelTilt means a physical wheel tilt
const PointerAxisSourceWheelTilt = 3

// PointerAxisRelativeDirectionIdentical means physical motion matches axis direction
const PointerAxisRelativeDirectionIdentical = 0

// PointerAxisRelativeDirectionInverted means physical motion is the inverse of the axis direction
const PointerAxisRelativeDirectionInverted = 1

// KeyboardKeymapFormatNoKeymap means no keymap; client must understand how to interpret the raw keycode
const KeyboardKeymapFormatNoKeymap = 0

// KeyboardKeymapFormatXkbV1 means libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
const KeyboardKeymapFormatXkbV1 = 1

// KeyboardKeyStateReleased means key is not pressed
const KeyboardKeyStateReleased = 0

// KeyboardKeyStatePressed means key is pressed
const KeyboardKeyStatePressed = 1

// KeyboardKeyStateRepeated means key was repeated
const KeyboardKeyStateRepeated = 2

// OutputSubpixelUnknown means unknown geometry
const OutputSubpixelUnknown = 0

// OutputSubpixelNone means no geometry
const OutputSubpixelNone = 1

// OutputSubpixelHorizontalRgb means horizontal RGB
const OutputSubpixelHorizontalRgb = 2

// OutputSubpixelHorizontalBgr means horizontal BGR
const OutputSubpixelHorizontalBgr = 3

// OutputSubpixelVerticalRgb means vertical RGB
const OutputSubpixelVerticalRgb = 4

// OutputSubpixelVerticalBgr means vertical BGR
const OutputSubpixelVerticalBgr = 5

// OutputTransformNormal means no transform
const OutputTransformNormal = 0

// OutputTransform90 means 90 degrees counter-clockwise
const OutputTransform90 = 1

// OutputTransform180 means 180 degrees counter-clockwise
const OutputTransform180 = 2

// OutputTransform270 means 270 degrees counter-clockwise
const OutputTransform270 = 3

// OutputTransformFlipped means 180 degree flip around a vertical axis
const OutputTransformFlipped = 4

// OutputTransformFlipped90 means flip and rotate 90 degrees counter-clockwise
const OutputTransformFlipped90 = 5

// OutputTransformFlipped180 means flip and rotate 180 degrees counter-clockwise
const OutputTransformFlipped180 = 6

// OutputTransformFlipped270 means flip and rotate 270 degrees counter-clockwise
const OutputTransformFlipped270 = 7

// OutputModeCurrent means indicates this is the current mode
const OutputModeCurrent = 0x1

// OutputModePreferred means indicates this is the preferred mode
const OutputModePreferred = 0x2

// SubcompositorErrorBadSurface means the to-be sub-surface is invalid
const SubcompositorErrorBadSurface = 0

// SubcompositorErrorBadParent means the to-be sub-surface parent is invalid
const SubcompositorErrorBadParent = 1

// SubsurfaceErrorBadSurface means wl_surface is not a sibling or the parent
const SubsurfaceErrorBadSurface = 0

// Display core global object
type Display struct {
	BaseProxy
	mu sync.RWMutex
	privateDisplayErrors map[DisplayErrorHandler]struct{}
	privateDisplayDeleteIds map[DisplayDeleteIdHandler]struct{}
}
// initDisplay initializes the Display object's handler maps
func (ret *Display) initDisplay() {
	ret.privateDisplayErrors = make(map[DisplayErrorHandler]struct{})
	ret.privateDisplayDeleteIds = make(map[DisplayDeleteIdHandler]struct{})
}
// NewDisplay is a constructor for the Display object
func NewDisplay(ctx *Context) *Display {
	ret := new(Display)
	ret.initDisplay()
	ctx.Register(ret)
	return ret
}
// Sync asynchronous roundtrip
func (p *Display) Sync() (*Callback, error) {
	retCallback := NewCallback(p.Context())
	return retCallback, p.Context().SendRequest(p, 0, retCallback)
}
// GetRegistry get global registry object
func (p *Display) GetRegistry() (*Registry, error) {
	retRegistry := NewRegistry(p.Context())
	return retRegistry, p.Context().SendRequest(p, 1, retRegistry)
}
// Dispatch dispatches event for object Display
func (p *Display) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDisplayErrors) > 0 {
			ev := DisplayErrorEvent{}
			ev.ObjectId = event.Proxy(p.Context())
			ev.Code = event.Uint32()
			ev.Message = event.String()
			p.mu.RLock()
			for h := range p.privateDisplayErrors {
				h.HandleDisplayError(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDisplayDeleteIds) > 0 {
			ev := DisplayDeleteIdEvent{}
			ev.Id = event.Uint32()
			p.mu.RLock()
			for h := range p.privateDisplayDeleteIds {
				h.HandleDisplayDeleteId(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// DisplayErrorEvent is the fatal error event
type DisplayErrorEvent struct {
	// ObjectId is the object where the error occurred
	ObjectId Proxy
	// Code is the error code
	Code uint32
	// Message is the error description
	Message string

}
// DisplayDeleteIdEvent is the acknowledge object ID deletion
type DisplayDeleteIdEvent struct {
	// Id is the deleted object ID
	Id uint32

}
// DisplayErrorHandler is the handler interface for DisplayErrorEvent
type DisplayErrorHandler interface {
	HandleDisplayError(DisplayErrorEvent)
}

// AddErrorHandler adds the Error handler
func (p *Display) AddErrorHandler(h DisplayErrorHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDisplayErrors[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveErrorHandler removes the Error handler
func (p *Display) RemoveErrorHandler(h DisplayErrorHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDisplayErrors, h)
}
// DisplayDeleteIdHandler is the handler interface for DisplayDeleteIdEvent
type DisplayDeleteIdHandler interface {
	HandleDisplayDeleteId(DisplayDeleteIdEvent)
}

// AddDeleteIdHandler adds the DeleteId handler
func (p *Display) AddDeleteIdHandler(h DisplayDeleteIdHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDisplayDeleteIds[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDeleteIdHandler removes the DeleteId handler
func (p *Display) RemoveDeleteIdHandler(h DisplayDeleteIdHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDisplayDeleteIds, h)
}
// Registry global registry object
type Registry struct {
	BaseProxy
	mu sync.RWMutex
	privateRegistryGlobals map[RegistryGlobalHandler]struct{}
	privateRegistryGlobalRemoves map[RegistryGlobalRemoveHandler]struct{}
}
// initRegistry initializes the Registry object's handler maps
func (ret *Registry) initRegistry() {
	ret.privateRegistryGlobals = make(map[RegistryGlobalHandler]struct{})
	ret.privateRegistryGlobalRemoves = make(map[RegistryGlobalRemoveHandler]struct{})
}
// NewRegistry is a constructor for the Registry object
func NewRegistry(ctx *Context) *Registry {
	ret := new(Registry)
	ret.initRegistry()
	ctx.Register(ret)
	return ret
}
// Bind bind an object to the display
func (p *Registry) Bind(Name uint32, Iface string, Version uint32, Id Proxy) (error) {
	
	return p.Context().SendRequest(p, 0, Name, Iface, Version, Id)
}
// Dispatch dispatches event for object Registry
func (p *Registry) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateRegistryGlobals) > 0 {
			ev := RegistryGlobalEvent{}
			ev.Name = event.Uint32()
			ev.Interface = event.String()
			ev.Version = event.Uint32()
			p.mu.RLock()
			for h := range p.privateRegistryGlobals {
				h.HandleRegistryGlobal(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateRegistryGlobalRemoves) > 0 {
			ev := RegistryGlobalRemoveEvent{}
			ev.Name = event.Uint32()
			p.mu.RLock()
			for h := range p.privateRegistryGlobalRemoves {
				h.HandleRegistryGlobalRemove(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// RegistryGlobalEvent is the announce global object
type RegistryGlobalEvent struct {
	// Name is the numeric name of the global object
	Name uint32
	// Interface is the interface implemented by the object
	Interface string
	// Version is the interface version
	Version uint32

}
// RegistryGlobalRemoveEvent is the announce removal of global object
type RegistryGlobalRemoveEvent struct {
	// Name is the numeric name of the global object
	Name uint32

}
// RegistryGlobalHandler is the handler interface for RegistryGlobalEvent
type RegistryGlobalHandler interface {
	HandleRegistryGlobal(RegistryGlobalEvent)
}

// AddGlobalHandler adds the Global handler
func (p *Registry) AddGlobalHandler(h RegistryGlobalHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateRegistryGlobals[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveGlobalHandler removes the Global handler
func (p *Registry) RemoveGlobalHandler(h RegistryGlobalHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateRegistryGlobals, h)
}
// RegistryGlobalRemoveHandler is the handler interface for RegistryGlobalRemoveEvent
type RegistryGlobalRemoveHandler interface {
	HandleRegistryGlobalRemove(RegistryGlobalRemoveEvent)
}

// AddGlobalRemoveHandler adds the GlobalRemove handler
func (p *Registry) AddGlobalRemoveHandler(h RegistryGlobalRemoveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateRegistryGlobalRemoves[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveGlobalRemoveHandler removes the GlobalRemove handler
func (p *Registry) RemoveGlobalRemoveHandler(h RegistryGlobalRemoveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateRegistryGlobalRemoves, h)
}
// Callback callback object
type Callback struct {
	BaseProxy
	mu sync.RWMutex
	privateCallbackDones map[CallbackDoneHandler]struct{}
}
// initCallback initializes the Callback object's handler maps
func (ret *Callback) initCallback() {
	ret.privateCallbackDones = make(map[CallbackDoneHandler]struct{})
}
// NewCallback is a constructor for the Callback object
func NewCallback(ctx *Context) *Callback {
	ret := new(Callback)
	ret.initCallback()
	ctx.Register(ret)
	return ret
}
// Dispatch dispatches event for object Callback
func (p *Callback) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateCallbackDones) > 0 {
			ev := CallbackDoneEvent{}
			ev.C = p
			ev.CallbackData = event.Uint32()
			p.mu.RLock()
			for h := range p.privateCallbackDones {
				h.HandleCallbackDone(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// CallbackDoneEvent is the done event
type CallbackDoneEvent struct {
	// CallbackData is the request-specific data for the callback
	CallbackData uint32
	C *Callback
}
// CallbackDoneHandler is the handler interface for CallbackDoneEvent
type CallbackDoneHandler interface {
	HandleCallbackDone(CallbackDoneEvent)
}

// AddDoneHandler adds the Done handler
func (p *Callback) AddDoneHandler(h CallbackDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateCallbackDones[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDoneHandler removes the Done handler
func (p *Callback) RemoveDoneHandler(h CallbackDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateCallbackDones, h)
}
// Compositor the compositor singleton
type Compositor struct {
	BaseProxy
}
// NewCompositor is a constructor for the Compositor object
func NewCompositor(ctx *Context) *Compositor {
	ret := new(Compositor)
	ctx.Register(ret)
	return ret
}
// CreateSurface create new surface
func (p *Compositor) CreateSurface() (*Surface, error) {
	retId := NewSurface(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId)
}
// CreateRegion create new region
func (p *Compositor) CreateRegion() (*Region, error) {
	retId := NewRegion(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}
// Dispatch dispatches event for object Compositor
func (p *Compositor) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// ShmPool a shared memory pool
type ShmPool struct {
	BaseProxy
}
// NewShmPool is a constructor for the ShmPool object
func NewShmPool(ctx *Context) *ShmPool {
	ret := new(ShmPool)
	ctx.Register(ret)
	return ret
}
// CreateBuffer create a buffer from the pool
func (p *ShmPool) CreateBuffer(Offset int32, Width int32, Height int32, Stride int32, Format uint32) (*Buffer, error) {
	retId := NewBuffer(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId, Offset, Width, Height, Stride, Format)
}
// Destroy destroy the pool
func (p *ShmPool) Destroy() (error) {
	
	return p.Context().SendRequest(p, 1)
}
// Resize change the size of the pool mapping
func (p *ShmPool) Resize(Size int32) (error) {
	
	return p.Context().SendRequest(p, 2, Size)
}
// Dispatch dispatches event for object ShmPool
func (p *ShmPool) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// Shm shared memory support
type Shm struct {
	BaseProxy
	mu sync.RWMutex
	privateShmFormats map[ShmFormatHandler]struct{}
}
// initShm initializes the Shm object's handler maps
func (ret *Shm) initShm() {
	ret.privateShmFormats = make(map[ShmFormatHandler]struct{})
}
// NewShm is a constructor for the Shm object
func NewShm(ctx *Context) *Shm {
	ret := new(Shm)
	ret.initShm()
	ctx.Register(ret)
	return ret
}
// CreatePool create a shm pool
func (p *Shm) CreatePool(Fd uintptr, Size int32) (*ShmPool, error) {
	retId := NewShmPool(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId, Fd, Size)
}
// Release release the shm object
func (p *Shm) Release() (error) {
	
	return p.Context().SendRequest(p, 1)
}
// Dispatch dispatches event for object Shm
func (p *Shm) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateShmFormats) > 0 {
			ev := ShmFormatEvent{}
			ev.Format = event.Uint32()
			p.mu.RLock()
			for h := range p.privateShmFormats {
				h.HandleShmFormat(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// ShmFormatEvent is the pixel format description
type ShmFormatEvent struct {
	// Format is the buffer pixel format
	Format uint32

}
// ShmFormatHandler is the handler interface for ShmFormatEvent
type ShmFormatHandler interface {
	HandleShmFormat(ShmFormatEvent)
}

// AddFormatHandler adds the Format handler
func (p *Shm) AddFormatHandler(h ShmFormatHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShmFormats[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveFormatHandler removes the Format handler
func (p *Shm) RemoveFormatHandler(h ShmFormatHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateShmFormats, h)
}
// Buffer content for a wl_surface
type Buffer struct {
	BaseProxy
	mu sync.RWMutex
	privateBufferReleases map[BufferReleaseHandler]struct{}
}
// initBuffer initializes the Buffer object's handler maps
func (ret *Buffer) initBuffer() {
	ret.privateBufferReleases = make(map[BufferReleaseHandler]struct{})
}
// NewBuffer is a constructor for the Buffer object
func NewBuffer(ctx *Context) *Buffer {
	ret := new(Buffer)
	ret.initBuffer()
	ctx.Register(ret)
	return ret
}
// Destroy destroy a buffer
func (p *Buffer) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// Dispatch dispatches event for object Buffer
func (p *Buffer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateBufferReleases) > 0 {
			ev := BufferReleaseEvent{}
			ev.B = p
			p.mu.RLock()
			for h := range p.privateBufferReleases {
				h.HandleBufferRelease(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// BufferReleaseEvent is the compositor releases buffer
type BufferReleaseEvent struct {
	B *Buffer
}
// BufferReleaseHandler is the handler interface for BufferReleaseEvent
type BufferReleaseHandler interface {
	HandleBufferRelease(BufferReleaseEvent)
}

// AddReleaseHandler adds the Release handler
func (p *Buffer) AddReleaseHandler(h BufferReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateBufferReleases[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveReleaseHandler removes the Release handler
func (p *Buffer) RemoveReleaseHandler(h BufferReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateBufferReleases, h)
}
// DataOffer offer to transfer data
type DataOffer struct {
	BaseProxy
	mu sync.RWMutex
	privateDataOfferOffers map[DataOfferOfferHandler]struct{}
	privateDataOfferSourceActionss map[DataOfferSourceActionsHandler]struct{}
	privateDataOfferActions map[DataOfferActionHandler]struct{}
}
// initDataOffer initializes the DataOffer object's handler maps
func (ret *DataOffer) initDataOffer() {
	ret.privateDataOfferOffers = make(map[DataOfferOfferHandler]struct{})
	ret.privateDataOfferSourceActionss = make(map[DataOfferSourceActionsHandler]struct{})
	ret.privateDataOfferActions = make(map[DataOfferActionHandler]struct{})
}
// NewDataOffer is a constructor for the DataOffer object
func NewDataOffer(ctx *Context) *DataOffer {
	ret := new(DataOffer)
	ret.initDataOffer()
	ctx.Register(ret)
	return ret
}
// Accept accept one of the offered mime types
func (p *DataOffer) Accept(Serial uint32, MimeType string) (error) {
	
	return p.Context().SendRequest(p, 0, Serial, MimeType)
}
// Receive request that the data is transferred
func (p *DataOffer) Receive(MimeType string, Fd uintptr) (error) {
	
	return p.Context().SendRequest(p, 1, MimeType, Fd)
}
// Destroy destroy data offer
func (p *DataOffer) Destroy() (error) {
	
	return p.Context().SendRequest(p, 2)
}
// Finish the offer will no longer be used
func (p *DataOffer) Finish() (error) {
	
	return p.Context().SendRequest(p, 3)
}
// SetActions set the available/preferred drag-and-drop actions
func (p *DataOffer) SetActions(DndActions uint32, PreferredAction uint32) (error) {
	
	return p.Context().SendRequest(p, 4, DndActions, PreferredAction)
}
// Dispatch dispatches event for object DataOffer
func (p *DataOffer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDataOfferOffers) > 0 {
			ev := DataOfferOfferEvent{}
			ev.MimeType = event.String()
			p.mu.RLock()
			for h := range p.privateDataOfferOffers {
				h.HandleDataOfferOffer(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDataOfferSourceActionss) > 0 {
			ev := DataOfferSourceActionsEvent{}
			ev.SourceActions = event.Uint32()
			p.mu.RLock()
			for h := range p.privateDataOfferSourceActionss {
				h.HandleDataOfferSourceActions(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateDataOfferActions) > 0 {
			ev := DataOfferActionEvent{}
			ev.DndAction = event.Uint32()
			p.mu.RLock()
			for h := range p.privateDataOfferActions {
				h.HandleDataOfferAction(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// DataOfferOfferEvent is the advertise offered mime type
type DataOfferOfferEvent struct {
	// MimeType is the offered mime type
	MimeType string

}
// DataOfferSourceActionsEvent is the notify the source-side available actions
type DataOfferSourceActionsEvent struct {
	// SourceActions is the actions offered by the data source
	SourceActions uint32

}
// DataOfferActionEvent is the notify the selected action
type DataOfferActionEvent struct {
	// DndAction is the action selected by the compositor
	DndAction uint32

}
// DataOfferOfferHandler is the handler interface for DataOfferOfferEvent
type DataOfferOfferHandler interface {
	HandleDataOfferOffer(DataOfferOfferEvent)
}

// AddOfferHandler adds the Offer handler
func (p *DataOffer) AddOfferHandler(h DataOfferOfferHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataOfferOffers[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveOfferHandler removes the Offer handler
func (p *DataOffer) RemoveOfferHandler(h DataOfferOfferHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataOfferOffers, h)
}
// DataOfferSourceActionsHandler is the handler interface for DataOfferSourceActionsEvent
type DataOfferSourceActionsHandler interface {
	HandleDataOfferSourceActions(DataOfferSourceActionsEvent)
}

// AddSourceActionsHandler adds the SourceActions handler
func (p *DataOffer) AddSourceActionsHandler(h DataOfferSourceActionsHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataOfferSourceActionss[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveSourceActionsHandler removes the SourceActions handler
func (p *DataOffer) RemoveSourceActionsHandler(h DataOfferSourceActionsHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataOfferSourceActionss, h)
}
// DataOfferActionHandler is the handler interface for DataOfferActionEvent
type DataOfferActionHandler interface {
	HandleDataOfferAction(DataOfferActionEvent)
}

// AddActionHandler adds the Action handler
func (p *DataOffer) AddActionHandler(h DataOfferActionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataOfferActions[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveActionHandler removes the Action handler
func (p *DataOffer) RemoveActionHandler(h DataOfferActionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataOfferActions, h)
}
// DataSource offer to transfer data
type DataSource struct {
	BaseProxy
	mu sync.RWMutex
	privateDataSourceTargets map[DataSourceTargetHandler]struct{}
	privateDataSourceSends map[DataSourceSendHandler]struct{}
	privateDataSourceCancelleds map[DataSourceCancelledHandler]struct{}
	privateDataSourceDndDropPerformeds map[DataSourceDndDropPerformedHandler]struct{}
	privateDataSourceDndFinisheds map[DataSourceDndFinishedHandler]struct{}
	privateDataSourceActions map[DataSourceActionHandler]struct{}
}
// initDataSource initializes the DataSource object's handler maps
func (ret *DataSource) initDataSource() {
	ret.privateDataSourceTargets = make(map[DataSourceTargetHandler]struct{})
	ret.privateDataSourceSends = make(map[DataSourceSendHandler]struct{})
	ret.privateDataSourceCancelleds = make(map[DataSourceCancelledHandler]struct{})
	ret.privateDataSourceDndDropPerformeds = make(map[DataSourceDndDropPerformedHandler]struct{})
	ret.privateDataSourceDndFinisheds = make(map[DataSourceDndFinishedHandler]struct{})
	ret.privateDataSourceActions = make(map[DataSourceActionHandler]struct{})
}
// NewDataSource is a constructor for the DataSource object
func NewDataSource(ctx *Context) *DataSource {
	ret := new(DataSource)
	ret.initDataSource()
	ctx.Register(ret)
	return ret
}
// Offer add an offered mime type
func (p *DataSource) Offer(MimeType string) (error) {
	
	return p.Context().SendRequest(p, 0, MimeType)
}
// Destroy destroy the data source
func (p *DataSource) Destroy() (error) {
	
	return p.Context().SendRequest(p, 1)
}
// SetActions set the available drag-and-drop actions
func (p *DataSource) SetActions(DndActions uint32) (error) {
	
	return p.Context().SendRequest(p, 2, DndActions)
}
// Dispatch dispatches event for object DataSource
func (p *DataSource) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDataSourceTargets) > 0 {
			ev := DataSourceTargetEvent{}
			ev.MimeType = event.String()
			p.mu.RLock()
			for h := range p.privateDataSourceTargets {
				h.HandleDataSourceTarget(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDataSourceSends) > 0 {
			ev := DataSourceSendEvent{}
			ev.MimeType = event.String()
			ev.Fd, ev.FdError = event.FD()
			p.mu.RLock()
			for h := range p.privateDataSourceSends {
				h.HandleDataSourceSend(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateDataSourceCancelleds) > 0 {
			ev := DataSourceCancelledEvent{}
			p.mu.RLock()
			for h := range p.privateDataSourceCancelleds {
				h.HandleDataSourceCancelled(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateDataSourceDndDropPerformeds) > 0 {
			ev := DataSourceDndDropPerformedEvent{}
			p.mu.RLock()
			for h := range p.privateDataSourceDndDropPerformeds {
				h.HandleDataSourceDndDropPerformed(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateDataSourceDndFinisheds) > 0 {
			ev := DataSourceDndFinishedEvent{}
			p.mu.RLock()
			for h := range p.privateDataSourceDndFinisheds {
				h.HandleDataSourceDndFinished(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateDataSourceActions) > 0 {
			ev := DataSourceActionEvent{}
			ev.DndAction = event.Uint32()
			p.mu.RLock()
			for h := range p.privateDataSourceActions {
				h.HandleDataSourceAction(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// DataSourceTargetEvent is the a target accepts an offered mime type
type DataSourceTargetEvent struct {
	// MimeType is the mime type accepted by the target
	MimeType string

}
// DataSourceSendEvent is the send the data
type DataSourceSendEvent struct {
	// MimeType is the mime type for the data
	MimeType string
	// Fd is the file descriptor for the data
	Fd uintptr
	// FdError is the file descriptor for the data (error)
	FdError error

}
// DataSourceCancelledEvent is the selection was cancelled
type DataSourceCancelledEvent struct {

}
// DataSourceDndDropPerformedEvent is the the drag-and-drop operation physically finished
type DataSourceDndDropPerformedEvent struct {

}
// DataSourceDndFinishedEvent is the the drag-and-drop operation concluded
type DataSourceDndFinishedEvent struct {

}
// DataSourceActionEvent is the notify the selected action
type DataSourceActionEvent struct {
	// DndAction is the action selected by the compositor
	DndAction uint32

}
// DataSourceTargetHandler is the handler interface for DataSourceTargetEvent
type DataSourceTargetHandler interface {
	HandleDataSourceTarget(DataSourceTargetEvent)
}

// AddTargetHandler adds the Target handler
func (p *DataSource) AddTargetHandler(h DataSourceTargetHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceTargets[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveTargetHandler removes the Target handler
func (p *DataSource) RemoveTargetHandler(h DataSourceTargetHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataSourceTargets, h)
}
// DataSourceSendHandler is the handler interface for DataSourceSendEvent
type DataSourceSendHandler interface {
	HandleDataSourceSend(DataSourceSendEvent)
}

// AddSendHandler adds the Send handler
func (p *DataSource) AddSendHandler(h DataSourceSendHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceSends[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveSendHandler removes the Send handler
func (p *DataSource) RemoveSendHandler(h DataSourceSendHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataSourceSends, h)
}
// DataSourceCancelledHandler is the handler interface for DataSourceCancelledEvent
type DataSourceCancelledHandler interface {
	HandleDataSourceCancelled(DataSourceCancelledEvent)
}

// AddCancelledHandler adds the Cancelled handler
func (p *DataSource) AddCancelledHandler(h DataSourceCancelledHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceCancelleds[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveCancelledHandler removes the Cancelled handler
func (p *DataSource) RemoveCancelledHandler(h DataSourceCancelledHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataSourceCancelleds, h)
}
// DataSourceDndDropPerformedHandler is the handler interface for DataSourceDndDropPerformedEvent
type DataSourceDndDropPerformedHandler interface {
	HandleDataSourceDndDropPerformed(DataSourceDndDropPerformedEvent)
}

// AddDndDropPerformedHandler adds the DndDropPerformed handler
func (p *DataSource) AddDndDropPerformedHandler(h DataSourceDndDropPerformedHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceDndDropPerformeds[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDndDropPerformedHandler removes the DndDropPerformed handler
func (p *DataSource) RemoveDndDropPerformedHandler(h DataSourceDndDropPerformedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataSourceDndDropPerformeds, h)
}
// DataSourceDndFinishedHandler is the handler interface for DataSourceDndFinishedEvent
type DataSourceDndFinishedHandler interface {
	HandleDataSourceDndFinished(DataSourceDndFinishedEvent)
}

// AddDndFinishedHandler adds the DndFinished handler
func (p *DataSource) AddDndFinishedHandler(h DataSourceDndFinishedHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceDndFinisheds[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDndFinishedHandler removes the DndFinished handler
func (p *DataSource) RemoveDndFinishedHandler(h DataSourceDndFinishedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataSourceDndFinisheds, h)
}
// DataSourceActionHandler is the handler interface for DataSourceActionEvent
type DataSourceActionHandler interface {
	HandleDataSourceAction(DataSourceActionEvent)
}

// AddActionHandler adds the Action handler
func (p *DataSource) AddActionHandler(h DataSourceActionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataSourceActions[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveActionHandler removes the Action handler
func (p *DataSource) RemoveActionHandler(h DataSourceActionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataSourceActions, h)
}
// DataDevice data transfer device
type DataDevice struct {
	BaseProxy
	mu sync.RWMutex
	privateDataDeviceDataOffers map[DataDeviceDataOfferHandler]struct{}
	privateDataDeviceEnters map[DataDeviceEnterHandler]struct{}
	privateDataDeviceLeaves map[DataDeviceLeaveHandler]struct{}
	privateDataDeviceMotions map[DataDeviceMotionHandler]struct{}
	privateDataDeviceDrops map[DataDeviceDropHandler]struct{}
	privateDataDeviceSelections map[DataDeviceSelectionHandler]struct{}
}
// initDataDevice initializes the DataDevice object's handler maps
func (ret *DataDevice) initDataDevice() {
	ret.privateDataDeviceDataOffers = make(map[DataDeviceDataOfferHandler]struct{})
	ret.privateDataDeviceEnters = make(map[DataDeviceEnterHandler]struct{})
	ret.privateDataDeviceLeaves = make(map[DataDeviceLeaveHandler]struct{})
	ret.privateDataDeviceMotions = make(map[DataDeviceMotionHandler]struct{})
	ret.privateDataDeviceDrops = make(map[DataDeviceDropHandler]struct{})
	ret.privateDataDeviceSelections = make(map[DataDeviceSelectionHandler]struct{})
}
// NewDataDevice is a constructor for the DataDevice object
func NewDataDevice(ctx *Context) *DataDevice {
	ret := new(DataDevice)
	ret.initDataDevice()
	ctx.Register(ret)
	return ret
}
// StartDrag start drag-and-drop operation
func (p *DataDevice) StartDrag(Source *DataSource, Origin *Surface, Icon *Surface, Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 0, Source, Origin, Icon, Serial)
}
// SetSelection copy data to the selection
func (p *DataDevice) SetSelection(Source *DataSource, Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 1, Source, Serial)
}
// Release destroy data device
func (p *DataDevice) Release() (error) {
	
	return p.Context().SendRequest(p, 2)
}
// Dispatch dispatches event for object DataDevice
func (p *DataDevice) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateDataDeviceDataOffers) > 0 {
			ev := DataDeviceDataOfferEvent{}
			ev.Id = func() *DataOffer { ret := new(DataOffer); ret.initDataOffer(); return event.NewId(ret, p.Context()).(*DataOffer) }()
			p.mu.RLock()
			for h := range p.privateDataDeviceDataOffers {
				h.HandleDataDeviceDataOffer(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateDataDeviceEnters) > 0 {
			ev := DataDeviceEnterEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = SafeCast[*Surface](event.Proxy(p.Context()))
			ev.X = event.Float32()
			ev.Y = event.Float32()
			ev.Id = SafeCast[*DataOffer](event.Proxy(p.Context()))
			p.mu.RLock()
			for h := range p.privateDataDeviceEnters {
				h.HandleDataDeviceEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateDataDeviceLeaves) > 0 {
			ev := DataDeviceLeaveEvent{}
			p.mu.RLock()
			for h := range p.privateDataDeviceLeaves {
				h.HandleDataDeviceLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateDataDeviceMotions) > 0 {
			ev := DataDeviceMotionEvent{}
			ev.Time = event.Uint32()
			ev.X = event.Float32()
			ev.Y = event.Float32()
			p.mu.RLock()
			for h := range p.privateDataDeviceMotions {
				h.HandleDataDeviceMotion(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateDataDeviceDrops) > 0 {
			ev := DataDeviceDropEvent{}
			p.mu.RLock()
			for h := range p.privateDataDeviceDrops {
				h.HandleDataDeviceDrop(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateDataDeviceSelections) > 0 {
			ev := DataDeviceSelectionEvent{}
			ev.Id = SafeCast[*DataOffer](event.Proxy(p.Context()))
			p.mu.RLock()
			for h := range p.privateDataDeviceSelections {
				h.HandleDataDeviceSelection(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// DataDeviceDataOfferEvent is the introduce a new wl_data_offer
type DataDeviceDataOfferEvent struct {
	// Id is the the new data_offer object
	Id *DataOffer

}
// DataDeviceEnterEvent is the initiate drag-and-drop session
type DataDeviceEnterEvent struct {
	// Serial is the serial number of the enter event
	Serial uint32
	// Surface is the client surface entered
	Surface *Surface
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32
	// Id is the source data_offer object
	Id *DataOffer

}
// DataDeviceLeaveEvent is the end drag-and-drop session
type DataDeviceLeaveEvent struct {

}
// DataDeviceMotionEvent is the drag-and-drop session motion
type DataDeviceMotionEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32

}
// DataDeviceDropEvent is the end drag-and-drop session successfully
type DataDeviceDropEvent struct {

}
// DataDeviceSelectionEvent is the advertise new selection
type DataDeviceSelectionEvent struct {
	// Id is the selection data_offer object
	Id *DataOffer

}
// DataDeviceDataOfferHandler is the handler interface for DataDeviceDataOfferEvent
type DataDeviceDataOfferHandler interface {
	HandleDataDeviceDataOffer(DataDeviceDataOfferEvent)
}

// AddDataOfferHandler adds the DataOffer handler
func (p *DataDevice) AddDataOfferHandler(h DataDeviceDataOfferHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceDataOffers[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDataOfferHandler removes the DataOffer handler
func (p *DataDevice) RemoveDataOfferHandler(h DataDeviceDataOfferHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataDeviceDataOffers, h)
}
// DataDeviceEnterHandler is the handler interface for DataDeviceEnterEvent
type DataDeviceEnterHandler interface {
	HandleDataDeviceEnter(DataDeviceEnterEvent)
}

// AddEnterHandler adds the Enter handler
func (p *DataDevice) AddEnterHandler(h DataDeviceEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceEnters[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveEnterHandler removes the Enter handler
func (p *DataDevice) RemoveEnterHandler(h DataDeviceEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataDeviceEnters, h)
}
// DataDeviceLeaveHandler is the handler interface for DataDeviceLeaveEvent
type DataDeviceLeaveHandler interface {
	HandleDataDeviceLeave(DataDeviceLeaveEvent)
}

// AddLeaveHandler adds the Leave handler
func (p *DataDevice) AddLeaveHandler(h DataDeviceLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceLeaves[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler removes the Leave handler
func (p *DataDevice) RemoveLeaveHandler(h DataDeviceLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataDeviceLeaves, h)
}
// DataDeviceMotionHandler is the handler interface for DataDeviceMotionEvent
type DataDeviceMotionHandler interface {
	HandleDataDeviceMotion(DataDeviceMotionEvent)
}

// AddMotionHandler adds the Motion handler
func (p *DataDevice) AddMotionHandler(h DataDeviceMotionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceMotions[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveMotionHandler removes the Motion handler
func (p *DataDevice) RemoveMotionHandler(h DataDeviceMotionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataDeviceMotions, h)
}
// DataDeviceDropHandler is the handler interface for DataDeviceDropEvent
type DataDeviceDropHandler interface {
	HandleDataDeviceDrop(DataDeviceDropEvent)
}

// AddDropHandler adds the Drop handler
func (p *DataDevice) AddDropHandler(h DataDeviceDropHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceDrops[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDropHandler removes the Drop handler
func (p *DataDevice) RemoveDropHandler(h DataDeviceDropHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataDeviceDrops, h)
}
// DataDeviceSelectionHandler is the handler interface for DataDeviceSelectionEvent
type DataDeviceSelectionHandler interface {
	HandleDataDeviceSelection(DataDeviceSelectionEvent)
}

// AddSelectionHandler adds the Selection handler
func (p *DataDevice) AddSelectionHandler(h DataDeviceSelectionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateDataDeviceSelections[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveSelectionHandler removes the Selection handler
func (p *DataDevice) RemoveSelectionHandler(h DataDeviceSelectionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateDataDeviceSelections, h)
}
// DataDeviceManager data transfer interface
type DataDeviceManager struct {
	BaseProxy
}
// NewDataDeviceManager is a constructor for the DataDeviceManager object
func NewDataDeviceManager(ctx *Context) *DataDeviceManager {
	ret := new(DataDeviceManager)
	ctx.Register(ret)
	return ret
}
// CreateDataSource create a new data source
func (p *DataDeviceManager) CreateDataSource() (*DataSource, error) {
	retId := NewDataSource(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId)
}
// GetDataDevice create a new data device
func (p *DataDeviceManager) GetDataDevice(Seat *Seat) (*DataDevice, error) {
	retId := NewDataDevice(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId, Seat)
}
// Dispatch dispatches event for object DataDeviceManager
func (p *DataDeviceManager) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// Shell create desktop-style surfaces
type Shell struct {
	BaseProxy
}
// NewShell is a constructor for the Shell object
func NewShell(ctx *Context) *Shell {
	ret := new(Shell)
	ctx.Register(ret)
	return ret
}
// GetShellSurface create a shell surface from a surface
func (p *Shell) GetShellSurface(Surface *Surface) (*ShellSurface, error) {
	retId := NewShellSurface(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId, Surface)
}
// Dispatch dispatches event for object Shell
func (p *Shell) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// ShellSurface desktop-style metadata interface
type ShellSurface struct {
	BaseProxy
	mu sync.RWMutex
	privateShellSurfacePings map[ShellSurfacePingHandler]struct{}
	privateShellSurfaceConfigures map[ShellSurfaceConfigureHandler]struct{}
	privateShellSurfacePopupDones map[ShellSurfacePopupDoneHandler]struct{}
}
// initShellSurface initializes the ShellSurface object's handler maps
func (ret *ShellSurface) initShellSurface() {
	ret.privateShellSurfacePings = make(map[ShellSurfacePingHandler]struct{})
	ret.privateShellSurfaceConfigures = make(map[ShellSurfaceConfigureHandler]struct{})
	ret.privateShellSurfacePopupDones = make(map[ShellSurfacePopupDoneHandler]struct{})
}
// NewShellSurface is a constructor for the ShellSurface object
func NewShellSurface(ctx *Context) *ShellSurface {
	ret := new(ShellSurface)
	ret.initShellSurface()
	ctx.Register(ret)
	return ret
}
// Pong respond to a ping event
func (p *ShellSurface) Pong(Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 0, Serial)
}
// Move start an interactive move
func (p *ShellSurface) Move(Seat *Seat, Serial uint32) (error) {
	
	return p.Context().SendRequest(p, 1, Seat, Serial)
}
// Resize start an interactive resize
func (p *ShellSurface) Resize(Seat *Seat, Serial uint32, Edges uint32) (error) {
	
	return p.Context().SendRequest(p, 2, Seat, Serial, Edges)
}
// SetToplevel make the surface a toplevel surface
func (p *ShellSurface) SetToplevel() (error) {
	
	return p.Context().SendRequest(p, 3)
}
// SetTransient make the surface a transient surface
func (p *ShellSurface) SetTransient(Parent *Surface, X int32, Y int32, Flags uint32) (error) {
	
	return p.Context().SendRequest(p, 4, Parent, X, Y, Flags)
}
// SetFullscreen make the surface a fullscreen surface
func (p *ShellSurface) SetFullscreen(Method uint32, Framerate uint32, Output *Output) (error) {
	
	return p.Context().SendRequest(p, 5, Method, Framerate, Output)
}
// SetPopup make the surface a popup surface
func (p *ShellSurface) SetPopup(Seat *Seat, Serial uint32, Parent *Surface, X int32, Y int32, Flags uint32) (error) {
	
	return p.Context().SendRequest(p, 6, Seat, Serial, Parent, X, Y, Flags)
}
// SetMaximized make the surface a maximized surface
func (p *ShellSurface) SetMaximized(Output *Output) (error) {
	
	return p.Context().SendRequest(p, 7, Output)
}
// SetTitle set surface title
func (p *ShellSurface) SetTitle(Title string) (error) {
	
	return p.Context().SendRequest(p, 8, Title)
}
// SetClass set surface class
func (p *ShellSurface) SetClass(Class string) (error) {
	
	return p.Context().SendRequest(p, 9, Class)
}
// Dispatch dispatches event for object ShellSurface
func (p *ShellSurface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateShellSurfacePings) > 0 {
			ev := ShellSurfacePingEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for h := range p.privateShellSurfacePings {
				h.HandleShellSurfacePing(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateShellSurfaceConfigures) > 0 {
			ev := ShellSurfaceConfigureEvent{}
			ev.Edges = event.Uint32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for h := range p.privateShellSurfaceConfigures {
				h.HandleShellSurfaceConfigure(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateShellSurfacePopupDones) > 0 {
			ev := ShellSurfacePopupDoneEvent{}
			p.mu.RLock()
			for h := range p.privateShellSurfacePopupDones {
				h.HandleShellSurfacePopupDone(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// ShellSurfacePingEvent is the ping client
type ShellSurfacePingEvent struct {
	// Serial is the serial number of the ping
	Serial uint32

}
// ShellSurfaceConfigureEvent is the suggest resize
type ShellSurfaceConfigureEvent struct {
	// Edges is the how the surface was resized
	Edges uint32
	// Width is the new width of the surface
	Width int32
	// Height is the new height of the surface
	Height int32

}
// ShellSurfacePopupDoneEvent is the popup interaction is done
type ShellSurfacePopupDoneEvent struct {

}
// ShellSurfacePingHandler is the handler interface for ShellSurfacePingEvent
type ShellSurfacePingHandler interface {
	HandleShellSurfacePing(ShellSurfacePingEvent)
}

// AddPingHandler adds the Ping handler
func (p *ShellSurface) AddPingHandler(h ShellSurfacePingHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShellSurfacePings[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemovePingHandler removes the Ping handler
func (p *ShellSurface) RemovePingHandler(h ShellSurfacePingHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateShellSurfacePings, h)
}
// ShellSurfaceConfigureHandler is the handler interface for ShellSurfaceConfigureEvent
type ShellSurfaceConfigureHandler interface {
	HandleShellSurfaceConfigure(ShellSurfaceConfigureEvent)
}

// AddConfigureHandler adds the Configure handler
func (p *ShellSurface) AddConfigureHandler(h ShellSurfaceConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShellSurfaceConfigures[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveConfigureHandler removes the Configure handler
func (p *ShellSurface) RemoveConfigureHandler(h ShellSurfaceConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateShellSurfaceConfigures, h)
}
// ShellSurfacePopupDoneHandler is the handler interface for ShellSurfacePopupDoneEvent
type ShellSurfacePopupDoneHandler interface {
	HandleShellSurfacePopupDone(ShellSurfacePopupDoneEvent)
}

// AddPopupDoneHandler adds the PopupDone handler
func (p *ShellSurface) AddPopupDoneHandler(h ShellSurfacePopupDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateShellSurfacePopupDones[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemovePopupDoneHandler removes the PopupDone handler
func (p *ShellSurface) RemovePopupDoneHandler(h ShellSurfacePopupDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateShellSurfacePopupDones, h)
}
// Surface an onscreen surface
type Surface struct {
	BaseProxy
	mu sync.RWMutex
	privateSurfaceEnters map[SurfaceEnterHandler]struct{}
	privateSurfaceLeaves map[SurfaceLeaveHandler]struct{}
	privateSurfacePreferredBufferScales map[SurfacePreferredBufferScaleHandler]struct{}
	privateSurfacePreferredBufferTransforms map[SurfacePreferredBufferTransformHandler]struct{}
}
// initSurface initializes the Surface object's handler maps
func (ret *Surface) initSurface() {
	ret.privateSurfaceEnters = make(map[SurfaceEnterHandler]struct{})
	ret.privateSurfaceLeaves = make(map[SurfaceLeaveHandler]struct{})
	ret.privateSurfacePreferredBufferScales = make(map[SurfacePreferredBufferScaleHandler]struct{})
	ret.privateSurfacePreferredBufferTransforms = make(map[SurfacePreferredBufferTransformHandler]struct{})
}
// NewSurface is a constructor for the Surface object
func NewSurface(ctx *Context) *Surface {
	ret := new(Surface)
	ret.initSurface()
	ctx.Register(ret)
	return ret
}
// Destroy delete surface
func (p *Surface) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// Attach set the surface contents
func (p *Surface) Attach(Buffer *Buffer, X int32, Y int32) (error) {
	
	return p.Context().SendRequest(p, 1, Buffer, X, Y)
}
// Damage mark part of the surface damaged
func (p *Surface) Damage(X int32, Y int32, Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 2, X, Y, Width, Height)
}
// Frame request a frame throttling hint
func (p *Surface) Frame() (*Callback, error) {
	retCallback := NewCallback(p.Context())
	return retCallback, p.Context().SendRequest(p, 3, retCallback)
}
// SetOpaqueRegion set opaque region
func (p *Surface) SetOpaqueRegion(Region *Region) (error) {
	
	return p.Context().SendRequest(p, 4, Region)
}
// SetInputRegion set input region
func (p *Surface) SetInputRegion(Region *Region) (error) {
	
	return p.Context().SendRequest(p, 5, Region)
}
// Commit commit pending surface state
func (p *Surface) Commit() (error) {
	
	return p.Context().SendRequest(p, 6)
}
// SetBufferTransform sets the buffer transformation
func (p *Surface) SetBufferTransform(Transform int32) (error) {
	
	return p.Context().SendRequest(p, 7, Transform)
}
// SetBufferScale sets the buffer scaling factor
func (p *Surface) SetBufferScale(Scale int32) (error) {
	
	return p.Context().SendRequest(p, 8, Scale)
}
// DamageBuffer mark part of the surface damaged using buffer coordinates
func (p *Surface) DamageBuffer(X int32, Y int32, Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 9, X, Y, Width, Height)
}
// Offset set the surface contents offset
func (p *Surface) Offset(X int32, Y int32) (error) {
	
	return p.Context().SendRequest(p, 10, X, Y)
}
// Dispatch dispatches event for object Surface
func (p *Surface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateSurfaceEnters) > 0 {
			ev := SurfaceEnterEvent{}
			ev.Output = SafeCast[*Output](event.Proxy(p.Context()))
			p.mu.RLock()
			for h := range p.privateSurfaceEnters {
				h.HandleSurfaceEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateSurfaceLeaves) > 0 {
			ev := SurfaceLeaveEvent{}
			ev.Output = SafeCast[*Output](event.Proxy(p.Context()))
			p.mu.RLock()
			for h := range p.privateSurfaceLeaves {
				h.HandleSurfaceLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateSurfacePreferredBufferScales) > 0 {
			ev := SurfacePreferredBufferScaleEvent{}
			ev.Factor = event.Int32()
			p.mu.RLock()
			for h := range p.privateSurfacePreferredBufferScales {
				h.HandleSurfacePreferredBufferScale(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateSurfacePreferredBufferTransforms) > 0 {
			ev := SurfacePreferredBufferTransformEvent{}
			ev.Transform = event.Uint32()
			p.mu.RLock()
			for h := range p.privateSurfacePreferredBufferTransforms {
				h.HandleSurfacePreferredBufferTransform(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// SurfaceEnterEvent is the surface enters an output
type SurfaceEnterEvent struct {
	// Output is the output entered by the surface
	Output *Output

}
// SurfaceLeaveEvent is the surface leaves an output
type SurfaceLeaveEvent struct {
	// Output is the output left by the surface
	Output *Output

}
// SurfacePreferredBufferScaleEvent is the preferred buffer scale for the surface
type SurfacePreferredBufferScaleEvent struct {
	// Factor is the preferred scaling factor
	Factor int32

}
// SurfacePreferredBufferTransformEvent is the preferred buffer transform for the surface
type SurfacePreferredBufferTransformEvent struct {
	// Transform is the preferred transform
	Transform uint32

}
// SurfaceEnterHandler is the handler interface for SurfaceEnterEvent
type SurfaceEnterHandler interface {
	HandleSurfaceEnter(SurfaceEnterEvent)
}

// AddEnterHandler adds the Enter handler
func (p *Surface) AddEnterHandler(h SurfaceEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfaceEnters[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveEnterHandler removes the Enter handler
func (p *Surface) RemoveEnterHandler(h SurfaceEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateSurfaceEnters, h)
}
// SurfaceLeaveHandler is the handler interface for SurfaceLeaveEvent
type SurfaceLeaveHandler interface {
	HandleSurfaceLeave(SurfaceLeaveEvent)
}

// AddLeaveHandler adds the Leave handler
func (p *Surface) AddLeaveHandler(h SurfaceLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfaceLeaves[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler removes the Leave handler
func (p *Surface) RemoveLeaveHandler(h SurfaceLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateSurfaceLeaves, h)
}
// SurfacePreferredBufferScaleHandler is the handler interface for SurfacePreferredBufferScaleEvent
type SurfacePreferredBufferScaleHandler interface {
	HandleSurfacePreferredBufferScale(SurfacePreferredBufferScaleEvent)
}

// AddPreferredBufferScaleHandler adds the PreferredBufferScale handler
func (p *Surface) AddPreferredBufferScaleHandler(h SurfacePreferredBufferScaleHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfacePreferredBufferScales[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemovePreferredBufferScaleHandler removes the PreferredBufferScale handler
func (p *Surface) RemovePreferredBufferScaleHandler(h SurfacePreferredBufferScaleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateSurfacePreferredBufferScales, h)
}
// SurfacePreferredBufferTransformHandler is the handler interface for SurfacePreferredBufferTransformEvent
type SurfacePreferredBufferTransformHandler interface {
	HandleSurfacePreferredBufferTransform(SurfacePreferredBufferTransformEvent)
}

// AddPreferredBufferTransformHandler adds the PreferredBufferTransform handler
func (p *Surface) AddPreferredBufferTransformHandler(h SurfacePreferredBufferTransformHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSurfacePreferredBufferTransforms[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemovePreferredBufferTransformHandler removes the PreferredBufferTransform handler
func (p *Surface) RemovePreferredBufferTransformHandler(h SurfacePreferredBufferTransformHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateSurfacePreferredBufferTransforms, h)
}
// Seat group of input devices
type Seat struct {
	BaseProxy
	mu sync.RWMutex
	privateSeatCapabilitiess map[SeatCapabilitiesHandler]struct{}
	privateSeatNames map[SeatNameHandler]struct{}
}
// initSeat initializes the Seat object's handler maps
func (ret *Seat) initSeat() {
	ret.privateSeatCapabilitiess = make(map[SeatCapabilitiesHandler]struct{})
	ret.privateSeatNames = make(map[SeatNameHandler]struct{})
}
// NewSeat is a constructor for the Seat object
func NewSeat(ctx *Context) *Seat {
	ret := new(Seat)
	ret.initSeat()
	ctx.Register(ret)
	return ret
}
// GetPointer return pointer object
func (p *Seat) GetPointer() (*Pointer, error) {
	retId := NewPointer(p.Context())
	return retId, p.Context().SendRequest(p, 0, retId)
}
// GetKeyboard return keyboard object
func (p *Seat) GetKeyboard() (*Keyboard, error) {
	retId := NewKeyboard(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId)
}
// GetTouch return touch object
func (p *Seat) GetTouch() (*Touch, error) {
	retId := NewTouch(p.Context())
	return retId, p.Context().SendRequest(p, 2, retId)
}
// Release release the seat object
func (p *Seat) Release() (error) {
	
	return p.Context().SendRequest(p, 3)
}
// Dispatch dispatches event for object Seat
func (p *Seat) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateSeatCapabilitiess) > 0 {
			ev := SeatCapabilitiesEvent{}
			ev.Capabilities = event.Uint32()
			p.mu.RLock()
			for h := range p.privateSeatCapabilitiess {
				h.HandleSeatCapabilities(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateSeatNames) > 0 {
			ev := SeatNameEvent{}
			ev.Name = event.String()
			p.mu.RLock()
			for h := range p.privateSeatNames {
				h.HandleSeatName(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// SeatCapabilitiesEvent is the seat capabilities changed
type SeatCapabilitiesEvent struct {
	// Capabilities is the capabilities of the seat
	Capabilities uint32

}
// SeatNameEvent is the unique identifier for this seat
type SeatNameEvent struct {
	// Name is the seat identifier
	Name string

}
// SeatCapabilitiesHandler is the handler interface for SeatCapabilitiesEvent
type SeatCapabilitiesHandler interface {
	HandleSeatCapabilities(SeatCapabilitiesEvent)
}

// AddCapabilitiesHandler adds the Capabilities handler
func (p *Seat) AddCapabilitiesHandler(h SeatCapabilitiesHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSeatCapabilitiess[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveCapabilitiesHandler removes the Capabilities handler
func (p *Seat) RemoveCapabilitiesHandler(h SeatCapabilitiesHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateSeatCapabilitiess, h)
}
// SeatNameHandler is the handler interface for SeatNameEvent
type SeatNameHandler interface {
	HandleSeatName(SeatNameEvent)
}

// AddNameHandler adds the Name handler
func (p *Seat) AddNameHandler(h SeatNameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateSeatNames[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveNameHandler removes the Name handler
func (p *Seat) RemoveNameHandler(h SeatNameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateSeatNames, h)
}
// Pointer pointer input device
type Pointer struct {
	BaseProxy
	mu sync.RWMutex
	privatePointerEnters map[PointerEnterHandler]struct{}
	privatePointerLeaves map[PointerLeaveHandler]struct{}
	privatePointerMotions map[PointerMotionHandler]struct{}
	privatePointerButtons map[PointerButtonHandler]struct{}
	privatePointerAxiss map[PointerAxisHandler]struct{}
	privatePointerFrames map[PointerFrameHandler]struct{}
	privatePointerAxisSources map[PointerAxisSourceHandler]struct{}
	privatePointerAxisStops map[PointerAxisStopHandler]struct{}
	privatePointerAxisDiscretes map[PointerAxisDiscreteHandler]struct{}
	privatePointerAxisValue120s map[PointerAxisValue120Handler]struct{}
	privatePointerAxisRelativeDirections map[PointerAxisRelativeDirectionHandler]struct{}
}
// initPointer initializes the Pointer object's handler maps
func (ret *Pointer) initPointer() {
	ret.privatePointerEnters = make(map[PointerEnterHandler]struct{})
	ret.privatePointerLeaves = make(map[PointerLeaveHandler]struct{})
	ret.privatePointerMotions = make(map[PointerMotionHandler]struct{})
	ret.privatePointerButtons = make(map[PointerButtonHandler]struct{})
	ret.privatePointerAxiss = make(map[PointerAxisHandler]struct{})
	ret.privatePointerFrames = make(map[PointerFrameHandler]struct{})
	ret.privatePointerAxisSources = make(map[PointerAxisSourceHandler]struct{})
	ret.privatePointerAxisStops = make(map[PointerAxisStopHandler]struct{})
	ret.privatePointerAxisDiscretes = make(map[PointerAxisDiscreteHandler]struct{})
	ret.privatePointerAxisValue120s = make(map[PointerAxisValue120Handler]struct{})
	ret.privatePointerAxisRelativeDirections = make(map[PointerAxisRelativeDirectionHandler]struct{})
}
// NewPointer is a constructor for the Pointer object
func NewPointer(ctx *Context) *Pointer {
	ret := new(Pointer)
	ret.initPointer()
	ctx.Register(ret)
	return ret
}
// SetCursor set the pointer surface
func (p *Pointer) SetCursor(Serial uint32, Surface *Surface, HotspotX int32, HotspotY int32) (error) {
	
	return p.Context().SendRequest(p, 0, Serial, Surface, HotspotX, HotspotY)
}
// Release release the pointer object
func (p *Pointer) Release() (error) {
	
	return p.Context().SendRequest(p, 1)
}
// Dispatch dispatches event for object Pointer
func (p *Pointer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privatePointerEnters) > 0 {
			ev := PointerEnterEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = SafeCast[*Surface](event.Proxy(p.Context()))
			ev.SurfaceX = event.Float32()
			ev.SurfaceY = event.Float32()
			p.mu.RLock()
			for h := range p.privatePointerEnters {
				h.HandlePointerEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privatePointerLeaves) > 0 {
			ev := PointerLeaveEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = SafeCast[*Surface](event.Proxy(p.Context()))
			p.mu.RLock()
			for h := range p.privatePointerLeaves {
				h.HandlePointerLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privatePointerMotions) > 0 {
			ev := PointerMotionEvent{}
			ev.P = p
			ev.Time = event.Uint32()
			ev.SurfaceX = event.Float32()
			ev.SurfaceY = event.Float32()
			p.mu.RLock()
			for h := range p.privatePointerMotions {
				h.HandlePointerMotion(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privatePointerButtons) > 0 {
			ev := PointerButtonEvent{}
			ev.P = p
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Button = event.Uint32()
			ev.State = event.Uint32()
			p.mu.RLock()
			for h := range p.privatePointerButtons {
				h.HandlePointerButton(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privatePointerAxiss) > 0 {
			ev := PointerAxisEvent{}
			ev.Time = event.Uint32()
			ev.Axis = event.Uint32()
			ev.Value = event.Float32()
			p.mu.RLock()
			for h := range p.privatePointerAxiss {
				h.HandlePointerAxis(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privatePointerFrames) > 0 {
			ev := PointerFrameEvent{}
			p.mu.RLock()
			for h := range p.privatePointerFrames {
				h.HandlePointerFrame(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.privatePointerAxisSources) > 0 {
			ev := PointerAxisSourceEvent{}
			ev.AxisSource = event.Uint32()
			p.mu.RLock()
			for h := range p.privatePointerAxisSources {
				h.HandlePointerAxisSource(ev)
			}
			p.mu.RUnlock()
		}
	case 7:
		if len(p.privatePointerAxisStops) > 0 {
			ev := PointerAxisStopEvent{}
			ev.Time = event.Uint32()
			ev.Axis = event.Uint32()
			p.mu.RLock()
			for h := range p.privatePointerAxisStops {
				h.HandlePointerAxisStop(ev)
			}
			p.mu.RUnlock()
		}
	case 8:
		if len(p.privatePointerAxisDiscretes) > 0 {
			ev := PointerAxisDiscreteEvent{}
			ev.Axis = event.Uint32()
			ev.Discrete = event.Int32()
			p.mu.RLock()
			for h := range p.privatePointerAxisDiscretes {
				h.HandlePointerAxisDiscrete(ev)
			}
			p.mu.RUnlock()
		}
	case 9:
		if len(p.privatePointerAxisValue120s) > 0 {
			ev := PointerAxisValue120Event{}
			ev.Axis = event.Uint32()
			ev.Value120 = event.Int32()
			p.mu.RLock()
			for h := range p.privatePointerAxisValue120s {
				h.HandlePointerAxisValue120(ev)
			}
			p.mu.RUnlock()
		}
	case 10:
		if len(p.privatePointerAxisRelativeDirections) > 0 {
			ev := PointerAxisRelativeDirectionEvent{}
			ev.Axis = event.Uint32()
			ev.Direction = event.Uint32()
			p.mu.RLock()
			for h := range p.privatePointerAxisRelativeDirections {
				h.HandlePointerAxisRelativeDirection(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// PointerEnterEvent is the enter event
type PointerEnterEvent struct {
	// Serial is the serial number of the enter event
	Serial uint32
	// Surface is the surface entered by the pointer
	Surface *Surface
	// SurfaceX is the surface-local x coordinate
	SurfaceX float32
	// SurfaceY is the surface-local y coordinate
	SurfaceY float32

}
// PointerLeaveEvent is the leave event
type PointerLeaveEvent struct {
	// Serial is the serial number of the leave event
	Serial uint32
	// Surface is the surface left by the pointer
	Surface *Surface

}
// PointerMotionEvent is the pointer motion event
type PointerMotionEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// SurfaceX is the surface-local x coordinate
	SurfaceX float32
	// SurfaceY is the surface-local y coordinate
	SurfaceY float32
	P *Pointer
}
// PointerButtonEvent is the pointer button event
type PointerButtonEvent struct {
	// Serial is the serial number of the button event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Button is the button that produced the event
	Button uint32
	// State is the physical state of the button
	State uint32
	P *Pointer
}
// PointerAxisEvent is the axis event
type PointerAxisEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Axis is the axis type
	Axis uint32
	// Value is the length of vector in surface-local coordinate space
	Value float32

}
// PointerFrameEvent is the end of a pointer event sequence
type PointerFrameEvent struct {

}
// PointerAxisSourceEvent is the axis source event
type PointerAxisSourceEvent struct {
	// AxisSource is the source of the axis event
	AxisSource uint32

}
// PointerAxisStopEvent is the axis stop event
type PointerAxisStopEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Axis is the the axis stopped with this event
	Axis uint32

}
// PointerAxisDiscreteEvent is the axis click event
type PointerAxisDiscreteEvent struct {
	// Axis is the axis type
	Axis uint32
	// Discrete is the number of steps
	Discrete int32

}
// PointerAxisValue120Event is the axis high-resolution scroll event
type PointerAxisValue120Event struct {
	// Axis is the axis type
	Axis uint32
	// Value120 is the scroll distance as fraction of 120
	Value120 int32

}
// PointerAxisRelativeDirectionEvent is the axis relative physical direction event
type PointerAxisRelativeDirectionEvent struct {
	// Axis is the axis type
	Axis uint32
	// Direction is the physical direction relative to axis motion
	Direction uint32

}
// PointerEnterHandler is the handler interface for PointerEnterEvent
type PointerEnterHandler interface {
	HandlePointerEnter(PointerEnterEvent)
}

// AddEnterHandler adds the Enter handler
func (p *Pointer) AddEnterHandler(h PointerEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerEnters[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveEnterHandler removes the Enter handler
func (p *Pointer) RemoveEnterHandler(h PointerEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerEnters, h)
}
// PointerLeaveHandler is the handler interface for PointerLeaveEvent
type PointerLeaveHandler interface {
	HandlePointerLeave(PointerLeaveEvent)
}

// AddLeaveHandler adds the Leave handler
func (p *Pointer) AddLeaveHandler(h PointerLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerLeaves[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler removes the Leave handler
func (p *Pointer) RemoveLeaveHandler(h PointerLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerLeaves, h)
}
// PointerMotionHandler is the handler interface for PointerMotionEvent
type PointerMotionHandler interface {
	HandlePointerMotion(PointerMotionEvent)
}

// AddMotionHandler adds the Motion handler
func (p *Pointer) AddMotionHandler(h PointerMotionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerMotions[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveMotionHandler removes the Motion handler
func (p *Pointer) RemoveMotionHandler(h PointerMotionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerMotions, h)
}
// PointerButtonHandler is the handler interface for PointerButtonEvent
type PointerButtonHandler interface {
	HandlePointerButton(PointerButtonEvent)
}

// AddButtonHandler adds the Button handler
func (p *Pointer) AddButtonHandler(h PointerButtonHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerButtons[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveButtonHandler removes the Button handler
func (p *Pointer) RemoveButtonHandler(h PointerButtonHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerButtons, h)
}
// PointerAxisHandler is the handler interface for PointerAxisEvent
type PointerAxisHandler interface {
	HandlePointerAxis(PointerAxisEvent)
}

// AddAxisHandler adds the Axis handler
func (p *Pointer) AddAxisHandler(h PointerAxisHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxiss[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveAxisHandler removes the Axis handler
func (p *Pointer) RemoveAxisHandler(h PointerAxisHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerAxiss, h)
}
// PointerFrameHandler is the handler interface for PointerFrameEvent
type PointerFrameHandler interface {
	HandlePointerFrame(PointerFrameEvent)
}

// AddFrameHandler adds the Frame handler
func (p *Pointer) AddFrameHandler(h PointerFrameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerFrames[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveFrameHandler removes the Frame handler
func (p *Pointer) RemoveFrameHandler(h PointerFrameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerFrames, h)
}
// PointerAxisSourceHandler is the handler interface for PointerAxisSourceEvent
type PointerAxisSourceHandler interface {
	HandlePointerAxisSource(PointerAxisSourceEvent)
}

// AddAxisSourceHandler adds the AxisSource handler
func (p *Pointer) AddAxisSourceHandler(h PointerAxisSourceHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisSources[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveAxisSourceHandler removes the AxisSource handler
func (p *Pointer) RemoveAxisSourceHandler(h PointerAxisSourceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerAxisSources, h)
}
// PointerAxisStopHandler is the handler interface for PointerAxisStopEvent
type PointerAxisStopHandler interface {
	HandlePointerAxisStop(PointerAxisStopEvent)
}

// AddAxisStopHandler adds the AxisStop handler
func (p *Pointer) AddAxisStopHandler(h PointerAxisStopHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisStops[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveAxisStopHandler removes the AxisStop handler
func (p *Pointer) RemoveAxisStopHandler(h PointerAxisStopHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerAxisStops, h)
}
// PointerAxisDiscreteHandler is the handler interface for PointerAxisDiscreteEvent
type PointerAxisDiscreteHandler interface {
	HandlePointerAxisDiscrete(PointerAxisDiscreteEvent)
}

// AddAxisDiscreteHandler adds the AxisDiscrete handler
func (p *Pointer) AddAxisDiscreteHandler(h PointerAxisDiscreteHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisDiscretes[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveAxisDiscreteHandler removes the AxisDiscrete handler
func (p *Pointer) RemoveAxisDiscreteHandler(h PointerAxisDiscreteHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerAxisDiscretes, h)
}
// PointerAxisValue120Handler is the handler interface for PointerAxisValue120Event
type PointerAxisValue120Handler interface {
	HandlePointerAxisValue120(PointerAxisValue120Event)
}

// AddAxisValue120Handler adds the AxisValue120 handler
func (p *Pointer) AddAxisValue120Handler(h PointerAxisValue120Handler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisValue120s[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveAxisValue120Handler removes the AxisValue120 handler
func (p *Pointer) RemoveAxisValue120Handler(h PointerAxisValue120Handler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerAxisValue120s, h)
}
// PointerAxisRelativeDirectionHandler is the handler interface for PointerAxisRelativeDirectionEvent
type PointerAxisRelativeDirectionHandler interface {
	HandlePointerAxisRelativeDirection(PointerAxisRelativeDirectionEvent)
}

// AddAxisRelativeDirectionHandler adds the AxisRelativeDirection handler
func (p *Pointer) AddAxisRelativeDirectionHandler(h PointerAxisRelativeDirectionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privatePointerAxisRelativeDirections[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveAxisRelativeDirectionHandler removes the AxisRelativeDirection handler
func (p *Pointer) RemoveAxisRelativeDirectionHandler(h PointerAxisRelativeDirectionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privatePointerAxisRelativeDirections, h)
}
// Keyboard keyboard input device
type Keyboard struct {
	BaseProxy
	mu sync.RWMutex
	privateKeyboardKeymaps map[KeyboardKeymapHandler]struct{}
	privateKeyboardEnters map[KeyboardEnterHandler]struct{}
	privateKeyboardLeaves map[KeyboardLeaveHandler]struct{}
	privateKeyboardKeys map[KeyboardKeyHandler]struct{}
	privateKeyboardModifierss map[KeyboardModifiersHandler]struct{}
	privateKeyboardRepeatInfos map[KeyboardRepeatInfoHandler]struct{}
}
// initKeyboard initializes the Keyboard object's handler maps
func (ret *Keyboard) initKeyboard() {
	ret.privateKeyboardKeymaps = make(map[KeyboardKeymapHandler]struct{})
	ret.privateKeyboardEnters = make(map[KeyboardEnterHandler]struct{})
	ret.privateKeyboardLeaves = make(map[KeyboardLeaveHandler]struct{})
	ret.privateKeyboardKeys = make(map[KeyboardKeyHandler]struct{})
	ret.privateKeyboardModifierss = make(map[KeyboardModifiersHandler]struct{})
	ret.privateKeyboardRepeatInfos = make(map[KeyboardRepeatInfoHandler]struct{})
}
// NewKeyboard is a constructor for the Keyboard object
func NewKeyboard(ctx *Context) *Keyboard {
	ret := new(Keyboard)
	ret.initKeyboard()
	ctx.Register(ret)
	return ret
}
// Release release the keyboard object
func (p *Keyboard) Release() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// Dispatch dispatches event for object Keyboard
func (p *Keyboard) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateKeyboardKeymaps) > 0 {
			ev := KeyboardKeymapEvent{}
			ev.Format = event.Uint32()
			ev.Fd, ev.FdError = event.FD()
			ev.Size = event.Uint32()
			p.mu.RLock()
			for h := range p.privateKeyboardKeymaps {
				h.HandleKeyboardKeymap(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateKeyboardEnters) > 0 {
			ev := KeyboardEnterEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = SafeCast[*Surface](event.Proxy(p.Context()))
			ev.Keys = event.Array()
			p.mu.RLock()
			for h := range p.privateKeyboardEnters {
				h.HandleKeyboardEnter(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateKeyboardLeaves) > 0 {
			ev := KeyboardLeaveEvent{}
			ev.Serial = event.Uint32()
			ev.Surface = SafeCast[*Surface](event.Proxy(p.Context()))
			p.mu.RLock()
			for h := range p.privateKeyboardLeaves {
				h.HandleKeyboardLeave(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateKeyboardKeys) > 0 {
			ev := KeyboardKeyEvent{}
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Key = event.Uint32()
			ev.State = event.Uint32()
			p.mu.RLock()
			for h := range p.privateKeyboardKeys {
				h.HandleKeyboardKey(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateKeyboardModifierss) > 0 {
			ev := KeyboardModifiersEvent{}
			ev.Serial = event.Uint32()
			ev.ModsDepressed = event.Uint32()
			ev.ModsLatched = event.Uint32()
			ev.ModsLocked = event.Uint32()
			ev.Group = event.Uint32()
			p.mu.RLock()
			for h := range p.privateKeyboardModifierss {
				h.HandleKeyboardModifiers(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateKeyboardRepeatInfos) > 0 {
			ev := KeyboardRepeatInfoEvent{}
			ev.Rate = event.Int32()
			ev.Delay = event.Int32()
			p.mu.RLock()
			for h := range p.privateKeyboardRepeatInfos {
				h.HandleKeyboardRepeatInfo(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// KeyboardKeymapEvent is the keyboard mapping
type KeyboardKeymapEvent struct {
	// Format is the keymap format
	Format uint32
	// Fd is the keymap file descriptor
	Fd uintptr
	// FdError is the keymap file descriptor (error)
	FdError error
	// Size is the keymap size, in bytes
	Size uint32

}
// KeyboardEnterEvent is the enter event
type KeyboardEnterEvent struct {
	// Serial is the serial number of the enter event
	Serial uint32
	// Surface is the surface gaining keyboard focus
	Surface *Surface
	// Keys is the the keys currently logically down
	Keys []int32

}
// KeyboardLeaveEvent is the leave event
type KeyboardLeaveEvent struct {
	// Serial is the serial number of the leave event
	Serial uint32
	// Surface is the surface that lost keyboard focus
	Surface *Surface

}
// KeyboardKeyEvent is the key event
type KeyboardKeyEvent struct {
	// Serial is the serial number of the key event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Key is the key that produced the event
	Key uint32
	// State is the physical state of the key
	State uint32

}
// KeyboardModifiersEvent is the modifier and group state
type KeyboardModifiersEvent struct {
	// Serial is the serial number of the modifiers event
	Serial uint32
	// ModsDepressed is the depressed modifiers
	ModsDepressed uint32
	// ModsLatched is the latched modifiers
	ModsLatched uint32
	// ModsLocked is the locked modifiers
	ModsLocked uint32
	// Group is the keyboard layout
	Group uint32

}
// KeyboardRepeatInfoEvent is the repeat rate and delay
type KeyboardRepeatInfoEvent struct {
	// Rate is the the rate of repeating keys in characters per second
	Rate int32
	// Delay is the delay in milliseconds since key down until repeating starts
	Delay int32

}
// KeyboardKeymapHandler is the handler interface for KeyboardKeymapEvent
type KeyboardKeymapHandler interface {
	HandleKeyboardKeymap(KeyboardKeymapEvent)
}

// AddKeymapHandler adds the Keymap handler
func (p *Keyboard) AddKeymapHandler(h KeyboardKeymapHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardKeymaps[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveKeymapHandler removes the Keymap handler
func (p *Keyboard) RemoveKeymapHandler(h KeyboardKeymapHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateKeyboardKeymaps, h)
}
// KeyboardEnterHandler is the handler interface for KeyboardEnterEvent
type KeyboardEnterHandler interface {
	HandleKeyboardEnter(KeyboardEnterEvent)
}

// AddEnterHandler adds the Enter handler
func (p *Keyboard) AddEnterHandler(h KeyboardEnterHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardEnters[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveEnterHandler removes the Enter handler
func (p *Keyboard) RemoveEnterHandler(h KeyboardEnterHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateKeyboardEnters, h)
}
// KeyboardLeaveHandler is the handler interface for KeyboardLeaveEvent
type KeyboardLeaveHandler interface {
	HandleKeyboardLeave(KeyboardLeaveEvent)
}

// AddLeaveHandler adds the Leave handler
func (p *Keyboard) AddLeaveHandler(h KeyboardLeaveHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardLeaves[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveLeaveHandler removes the Leave handler
func (p *Keyboard) RemoveLeaveHandler(h KeyboardLeaveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateKeyboardLeaves, h)
}
// KeyboardKeyHandler is the handler interface for KeyboardKeyEvent
type KeyboardKeyHandler interface {
	HandleKeyboardKey(KeyboardKeyEvent)
}

// AddKeyHandler adds the Key handler
func (p *Keyboard) AddKeyHandler(h KeyboardKeyHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardKeys[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveKeyHandler removes the Key handler
func (p *Keyboard) RemoveKeyHandler(h KeyboardKeyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateKeyboardKeys, h)
}
// KeyboardModifiersHandler is the handler interface for KeyboardModifiersEvent
type KeyboardModifiersHandler interface {
	HandleKeyboardModifiers(KeyboardModifiersEvent)
}

// AddModifiersHandler adds the Modifiers handler
func (p *Keyboard) AddModifiersHandler(h KeyboardModifiersHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardModifierss[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveModifiersHandler removes the Modifiers handler
func (p *Keyboard) RemoveModifiersHandler(h KeyboardModifiersHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateKeyboardModifierss, h)
}
// KeyboardRepeatInfoHandler is the handler interface for KeyboardRepeatInfoEvent
type KeyboardRepeatInfoHandler interface {
	HandleKeyboardRepeatInfo(KeyboardRepeatInfoEvent)
}

// AddRepeatInfoHandler adds the RepeatInfo handler
func (p *Keyboard) AddRepeatInfoHandler(h KeyboardRepeatInfoHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateKeyboardRepeatInfos[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveRepeatInfoHandler removes the RepeatInfo handler
func (p *Keyboard) RemoveRepeatInfoHandler(h KeyboardRepeatInfoHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateKeyboardRepeatInfos, h)
}
// Touch touchscreen input device
type Touch struct {
	BaseProxy
	mu sync.RWMutex
	privateTouchDowns map[TouchDownHandler]struct{}
	privateTouchUps map[TouchUpHandler]struct{}
	privateTouchMotions map[TouchMotionHandler]struct{}
	privateTouchFrames map[TouchFrameHandler]struct{}
	privateTouchCancels map[TouchCancelHandler]struct{}
	privateTouchShapes map[TouchShapeHandler]struct{}
	privateTouchOrientations map[TouchOrientationHandler]struct{}
}
// initTouch initializes the Touch object's handler maps
func (ret *Touch) initTouch() {
	ret.privateTouchDowns = make(map[TouchDownHandler]struct{})
	ret.privateTouchUps = make(map[TouchUpHandler]struct{})
	ret.privateTouchMotions = make(map[TouchMotionHandler]struct{})
	ret.privateTouchFrames = make(map[TouchFrameHandler]struct{})
	ret.privateTouchCancels = make(map[TouchCancelHandler]struct{})
	ret.privateTouchShapes = make(map[TouchShapeHandler]struct{})
	ret.privateTouchOrientations = make(map[TouchOrientationHandler]struct{})
}
// NewTouch is a constructor for the Touch object
func NewTouch(ctx *Context) *Touch {
	ret := new(Touch)
	ret.initTouch()
	ctx.Register(ret)
	return ret
}
// Release release the touch object
func (p *Touch) Release() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// Dispatch dispatches event for object Touch
func (p *Touch) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateTouchDowns) > 0 {
			ev := TouchDownEvent{}
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Surface = SafeCast[*Surface](event.Proxy(p.Context()))
			ev.Id = event.Int32()
			ev.X = event.Float32()
			ev.Y = event.Float32()
			p.mu.RLock()
			for h := range p.privateTouchDowns {
				h.HandleTouchDown(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateTouchUps) > 0 {
			ev := TouchUpEvent{}
			ev.Serial = event.Uint32()
			ev.Time = event.Uint32()
			ev.Id = event.Int32()
			p.mu.RLock()
			for h := range p.privateTouchUps {
				h.HandleTouchUp(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateTouchMotions) > 0 {
			ev := TouchMotionEvent{}
			ev.Time = event.Uint32()
			ev.Id = event.Int32()
			ev.X = event.Float32()
			ev.Y = event.Float32()
			p.mu.RLock()
			for h := range p.privateTouchMotions {
				h.HandleTouchMotion(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateTouchFrames) > 0 {
			ev := TouchFrameEvent{}
			p.mu.RLock()
			for h := range p.privateTouchFrames {
				h.HandleTouchFrame(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateTouchCancels) > 0 {
			ev := TouchCancelEvent{}
			p.mu.RLock()
			for h := range p.privateTouchCancels {
				h.HandleTouchCancel(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateTouchShapes) > 0 {
			ev := TouchShapeEvent{}
			ev.Id = event.Int32()
			ev.Major = event.Float32()
			ev.Minor = event.Float32()
			p.mu.RLock()
			for h := range p.privateTouchShapes {
				h.HandleTouchShape(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.privateTouchOrientations) > 0 {
			ev := TouchOrientationEvent{}
			ev.Id = event.Int32()
			ev.Orientation = event.Float32()
			p.mu.RLock()
			for h := range p.privateTouchOrientations {
				h.HandleTouchOrientation(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// TouchDownEvent is the touch down event and beginning of a touch sequence
type TouchDownEvent struct {
	// Serial is the serial number of the touch down event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Surface is the surface touched
	Surface *Surface
	// Id is the the unique ID of this touch point
	Id int32
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32

}
// TouchUpEvent is the end of a touch event sequence
type TouchUpEvent struct {
	// Serial is the serial number of the touch up event
	Serial uint32
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Id is the the unique ID of this touch point
	Id int32

}
// TouchMotionEvent is the update of touch point coordinates
type TouchMotionEvent struct {
	// Time is the timestamp with millisecond granularity
	Time uint32
	// Id is the the unique ID of this touch point
	Id int32
	// X is the surface-local x coordinate
	X float32
	// Y is the surface-local y coordinate
	Y float32

}
// TouchFrameEvent is the end of touch frame event
type TouchFrameEvent struct {

}
// TouchCancelEvent is the touch session cancelled
type TouchCancelEvent struct {

}
// TouchShapeEvent is the update shape of touch point
type TouchShapeEvent struct {
	// Id is the the unique ID of this touch point
	Id int32
	// Major is the length of the major axis in surface-local coordinates
	Major float32
	// Minor is the length of the minor axis in surface-local coordinates
	Minor float32

}
// TouchOrientationEvent is the update orientation of touch point
type TouchOrientationEvent struct {
	// Id is the the unique ID of this touch point
	Id int32
	// Orientation is the angle between major axis and positive surface y-axis in degrees
	Orientation float32

}
// TouchDownHandler is the handler interface for TouchDownEvent
type TouchDownHandler interface {
	HandleTouchDown(TouchDownEvent)
}

// AddDownHandler adds the Down handler
func (p *Touch) AddDownHandler(h TouchDownHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchDowns[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDownHandler removes the Down handler
func (p *Touch) RemoveDownHandler(h TouchDownHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateTouchDowns, h)
}
// TouchUpHandler is the handler interface for TouchUpEvent
type TouchUpHandler interface {
	HandleTouchUp(TouchUpEvent)
}

// AddUpHandler adds the Up handler
func (p *Touch) AddUpHandler(h TouchUpHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchUps[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveUpHandler removes the Up handler
func (p *Touch) RemoveUpHandler(h TouchUpHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateTouchUps, h)
}
// TouchMotionHandler is the handler interface for TouchMotionEvent
type TouchMotionHandler interface {
	HandleTouchMotion(TouchMotionEvent)
}

// AddMotionHandler adds the Motion handler
func (p *Touch) AddMotionHandler(h TouchMotionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchMotions[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveMotionHandler removes the Motion handler
func (p *Touch) RemoveMotionHandler(h TouchMotionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateTouchMotions, h)
}
// TouchFrameHandler is the handler interface for TouchFrameEvent
type TouchFrameHandler interface {
	HandleTouchFrame(TouchFrameEvent)
}

// AddFrameHandler adds the Frame handler
func (p *Touch) AddFrameHandler(h TouchFrameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchFrames[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveFrameHandler removes the Frame handler
func (p *Touch) RemoveFrameHandler(h TouchFrameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateTouchFrames, h)
}
// TouchCancelHandler is the handler interface for TouchCancelEvent
type TouchCancelHandler interface {
	HandleTouchCancel(TouchCancelEvent)
}

// AddCancelHandler adds the Cancel handler
func (p *Touch) AddCancelHandler(h TouchCancelHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchCancels[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveCancelHandler removes the Cancel handler
func (p *Touch) RemoveCancelHandler(h TouchCancelHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateTouchCancels, h)
}
// TouchShapeHandler is the handler interface for TouchShapeEvent
type TouchShapeHandler interface {
	HandleTouchShape(TouchShapeEvent)
}

// AddShapeHandler adds the Shape handler
func (p *Touch) AddShapeHandler(h TouchShapeHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchShapes[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveShapeHandler removes the Shape handler
func (p *Touch) RemoveShapeHandler(h TouchShapeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateTouchShapes, h)
}
// TouchOrientationHandler is the handler interface for TouchOrientationEvent
type TouchOrientationHandler interface {
	HandleTouchOrientation(TouchOrientationEvent)
}

// AddOrientationHandler adds the Orientation handler
func (p *Touch) AddOrientationHandler(h TouchOrientationHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateTouchOrientations[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveOrientationHandler removes the Orientation handler
func (p *Touch) RemoveOrientationHandler(h TouchOrientationHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateTouchOrientations, h)
}
// Output compositor output region
type Output struct {
	BaseProxy
	mu sync.RWMutex
	privateOutputGeometrys map[OutputGeometryHandler]struct{}
	privateOutputModes map[OutputModeHandler]struct{}
	privateOutputDones map[OutputDoneHandler]struct{}
	privateOutputScales map[OutputScaleHandler]struct{}
	privateOutputNames map[OutputNameHandler]struct{}
	privateOutputDescriptions map[OutputDescriptionHandler]struct{}
}
// initOutput initializes the Output object's handler maps
func (ret *Output) initOutput() {
	ret.privateOutputGeometrys = make(map[OutputGeometryHandler]struct{})
	ret.privateOutputModes = make(map[OutputModeHandler]struct{})
	ret.privateOutputDones = make(map[OutputDoneHandler]struct{})
	ret.privateOutputScales = make(map[OutputScaleHandler]struct{})
	ret.privateOutputNames = make(map[OutputNameHandler]struct{})
	ret.privateOutputDescriptions = make(map[OutputDescriptionHandler]struct{})
}
// NewOutput is a constructor for the Output object
func NewOutput(ctx *Context) *Output {
	ret := new(Output)
	ret.initOutput()
	ctx.Register(ret)
	return ret
}
// Release release the output object
func (p *Output) Release() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// Dispatch dispatches event for object Output
func (p *Output) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.privateOutputGeometrys) > 0 {
			ev := OutputGeometryEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.PhysicalWidth = event.Int32()
			ev.PhysicalHeight = event.Int32()
			ev.Subpixel = event.Int32()
			ev.Make = event.String()
			ev.Model = event.String()
			ev.Transform = event.Int32()
			p.mu.RLock()
			for h := range p.privateOutputGeometrys {
				h.HandleOutputGeometry(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.privateOutputModes) > 0 {
			ev := OutputModeEvent{}
			ev.Flags = event.Uint32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			ev.Refresh = event.Int32()
			p.mu.RLock()
			for h := range p.privateOutputModes {
				h.HandleOutputMode(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.privateOutputDones) > 0 {
			ev := OutputDoneEvent{}
			p.mu.RLock()
			for h := range p.privateOutputDones {
				h.HandleOutputDone(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.privateOutputScales) > 0 {
			ev := OutputScaleEvent{}
			ev.Factor = event.Int32()
			p.mu.RLock()
			for h := range p.privateOutputScales {
				h.HandleOutputScale(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.privateOutputNames) > 0 {
			ev := OutputNameEvent{}
			ev.Name = event.String()
			p.mu.RLock()
			for h := range p.privateOutputNames {
				h.HandleOutputName(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.privateOutputDescriptions) > 0 {
			ev := OutputDescriptionEvent{}
			ev.Description = event.String()
			p.mu.RLock()
			for h := range p.privateOutputDescriptions {
				h.HandleOutputDescription(ev)
			}
			p.mu.RUnlock()
		}

	}
}
// OutputGeometryEvent is the properties of the output
type OutputGeometryEvent struct {
	// X is the x position within the global compositor space
	X int32
	// Y is the y position within the global compositor space
	Y int32
	// PhysicalWidth is the width in millimeters of the output
	PhysicalWidth int32
	// PhysicalHeight is the height in millimeters of the output
	PhysicalHeight int32
	// Subpixel is the subpixel orientation of the output
	Subpixel int32
	// Make is the textual description of the manufacturer
	Make string
	// Model is the textual description of the model
	Model string
	// Transform is the additional transformation applied to buffer contents during presentation
	Transform int32

}
// OutputModeEvent is the advertise available modes for the output
type OutputModeEvent struct {
	// Flags is the bitfield of mode flags
	Flags uint32
	// Width is the width of the mode in hardware units
	Width int32
	// Height is the height of the mode in hardware units
	Height int32
	// Refresh is the vertical refresh rate in mHz
	Refresh int32

}
// OutputDoneEvent is the sent all information about output
type OutputDoneEvent struct {

}
// OutputScaleEvent is the output scaling properties
type OutputScaleEvent struct {
	// Factor is the scaling factor of output
	Factor int32

}
// OutputNameEvent is the name of this output
type OutputNameEvent struct {
	// Name is the output name
	Name string

}
// OutputDescriptionEvent is the human-readable description of this output
type OutputDescriptionEvent struct {
	// Description is the output description
	Description string

}
// OutputGeometryHandler is the handler interface for OutputGeometryEvent
type OutputGeometryHandler interface {
	HandleOutputGeometry(OutputGeometryEvent)
}

// AddGeometryHandler adds the Geometry handler
func (p *Output) AddGeometryHandler(h OutputGeometryHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputGeometrys[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveGeometryHandler removes the Geometry handler
func (p *Output) RemoveGeometryHandler(h OutputGeometryHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateOutputGeometrys, h)
}
// OutputModeHandler is the handler interface for OutputModeEvent
type OutputModeHandler interface {
	HandleOutputMode(OutputModeEvent)
}

// AddModeHandler adds the Mode handler
func (p *Output) AddModeHandler(h OutputModeHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputModes[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveModeHandler removes the Mode handler
func (p *Output) RemoveModeHandler(h OutputModeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateOutputModes, h)
}
// OutputDoneHandler is the handler interface for OutputDoneEvent
type OutputDoneHandler interface {
	HandleOutputDone(OutputDoneEvent)
}

// AddDoneHandler adds the Done handler
func (p *Output) AddDoneHandler(h OutputDoneHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputDones[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDoneHandler removes the Done handler
func (p *Output) RemoveDoneHandler(h OutputDoneHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateOutputDones, h)
}
// OutputScaleHandler is the handler interface for OutputScaleEvent
type OutputScaleHandler interface {
	HandleOutputScale(OutputScaleEvent)
}

// AddScaleHandler adds the Scale handler
func (p *Output) AddScaleHandler(h OutputScaleHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputScales[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveScaleHandler removes the Scale handler
func (p *Output) RemoveScaleHandler(h OutputScaleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateOutputScales, h)
}
// OutputNameHandler is the handler interface for OutputNameEvent
type OutputNameHandler interface {
	HandleOutputName(OutputNameEvent)
}

// AddNameHandler adds the Name handler
func (p *Output) AddNameHandler(h OutputNameHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputNames[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveNameHandler removes the Name handler
func (p *Output) RemoveNameHandler(h OutputNameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateOutputNames, h)
}
// OutputDescriptionHandler is the handler interface for OutputDescriptionEvent
type OutputDescriptionHandler interface {
	HandleOutputDescription(OutputDescriptionEvent)
}

// AddDescriptionHandler adds the Description handler
func (p *Output) AddDescriptionHandler(h OutputDescriptionHandler) {
	if h != nil {
		p.mu.Lock()
		p.privateOutputDescriptions[h] = struct{}{}
		p.mu.Unlock()
	}
}

// RemoveDescriptionHandler removes the Description handler
func (p *Output) RemoveDescriptionHandler(h OutputDescriptionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	delete (p.privateOutputDescriptions, h)
}
// Region region interface
type Region struct {
	BaseProxy
}
// NewRegion is a constructor for the Region object
func NewRegion(ctx *Context) *Region {
	ret := new(Region)
	ctx.Register(ret)
	return ret
}
// Destroy destroy region
func (p *Region) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// Add add rectangle to region
func (p *Region) Add(X int32, Y int32, Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 1, X, Y, Width, Height)
}
// Subtract subtract rectangle from region
func (p *Region) Subtract(X int32, Y int32, Width int32, Height int32) (error) {
	
	return p.Context().SendRequest(p, 2, X, Y, Width, Height)
}
// Dispatch dispatches event for object Region
func (p *Region) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// Subcompositor sub-surface compositing
type Subcompositor struct {
	BaseProxy
}
// NewSubcompositor is a constructor for the Subcompositor object
func NewSubcompositor(ctx *Context) *Subcompositor {
	ret := new(Subcompositor)
	ctx.Register(ret)
	return ret
}
// Destroy unbind from the subcompositor interface
func (p *Subcompositor) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// GetSubsurface give a surface the role sub-surface
func (p *Subcompositor) GetSubsurface(Surface *Surface, Parent *Surface) (*Subsurface, error) {
	retId := NewSubsurface(p.Context())
	return retId, p.Context().SendRequest(p, 1, retId, Surface, Parent)
}
// Dispatch dispatches event for object Subcompositor
func (p *Subcompositor) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// Subsurface sub-surface interface to a wl_surface
type Subsurface struct {
	BaseProxy
}
// NewSubsurface is a constructor for the Subsurface object
func NewSubsurface(ctx *Context) *Subsurface {
	ret := new(Subsurface)
	ctx.Register(ret)
	return ret
}
// Destroy remove sub-surface interface
func (p *Subsurface) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// SetPosition reposition the sub-surface
func (p *Subsurface) SetPosition(X int32, Y int32) (error) {
	
	return p.Context().SendRequest(p, 1, X, Y)
}
// PlaceAbove restack the sub-surface
func (p *Subsurface) PlaceAbove(Sibling *Surface) (error) {
	
	return p.Context().SendRequest(p, 2, Sibling)
}
// PlaceBelow restack the sub-surface
func (p *Subsurface) PlaceBelow(Sibling *Surface) (error) {
	
	return p.Context().SendRequest(p, 3, Sibling)
}
// SetSync set sub-surface to synchronized mode
func (p *Subsurface) SetSync() (error) {
	
	return p.Context().SendRequest(p, 4)
}
// SetDesync set sub-surface to desynchronized mode
func (p *Subsurface) SetDesync() (error) {
	
	return p.Context().SendRequest(p, 5)
}
// Dispatch dispatches event for object Subsurface
func (p *Subsurface) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
// Fixes wayland protocol fixes
type Fixes struct {
	BaseProxy
}
// NewFixes is a constructor for the Fixes object
func NewFixes(ctx *Context) *Fixes {
	ret := new(Fixes)
	ctx.Register(ret)
	return ret
}
// Destroy destroys this object
func (p *Fixes) Destroy() (error) {
	
	return p.Context().SendRequest(p, 0)
}
// DestroyRegistry destroy a wl_registry
func (p *Fixes) DestroyRegistry(Registry *Registry) (error) {
	
	return p.Context().SendRequest(p, 1, Registry)
}
// Dispatch dispatches event for object Fixes
func (p *Fixes) Dispatch(event *Event) {
	switch event.Opcode {

	}
}
